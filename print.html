<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hermes (IBC Relayer CLI) Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Hermes (v1.0.0)</li><li class="spacer"></li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="relayer.html"><strong aria-hidden="true">1.1.</strong> What is Hermes?</a></li></ol></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="features/matrix.html"><strong aria-hidden="true">2.1.</strong> Feature matrix</a></li></ol></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pre_requisites.html"><strong aria-hidden="true">3.1.</strong> Pre-requisites</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">3.2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="config.html"><strong aria-hidden="true">3.3.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="example-config.html"><strong aria-hidden="true">3.3.1.</strong> Example Configuration</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="telemetry.html"><strong aria-hidden="true">4.</strong> Telemetry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="telemetry/operators.html"><strong aria-hidden="true">4.1.</strong> Operators guide</a></li><li class="chapter-item expanded "><a href="telemetry/integration.html"><strong aria-hidden="true">4.2.</strong> Integration</a></li></ol></li><li class="chapter-item expanded "><a href="rest-api.html"><strong aria-hidden="true">5.</strong> REST API</a></li><li class="chapter-item expanded "><a href="tutorials/index.html"><strong aria-hidden="true">6.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/index.html"><strong aria-hidden="true">6.1.</strong> Local chains</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/gaia.html"><strong aria-hidden="true">6.1.1.</strong> Install Gaia</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/gaiad-manager.html"><strong aria-hidden="true">6.1.2.</strong> Install Gaiad Manager</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/start.html"><strong aria-hidden="true">6.1.3.</strong> Start the local chains</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/identifiers.html"><strong aria-hidden="true">6.1.4.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/index.html"><strong aria-hidden="true">6.1.5.</strong> Connect the chains using relay paths</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/create-new-path.html"><strong aria-hidden="true">6.1.5.1.</strong> Create a new path</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/multiple-paths.html"><strong aria-hidden="true">6.1.5.2.</strong> Relay packets on multiple paths</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="commands/index.html"><strong aria-hidden="true">7.</strong> Commands Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/global.html"><strong aria-hidden="true">7.1.</strong> Global options and JSON output</a></li><li class="chapter-item expanded "><a href="commands/keys/index.html"><strong aria-hidden="true">7.2.</strong> Keys</a></li><li class="chapter-item expanded "><a href="commands/config.html"><strong aria-hidden="true">7.3.</strong> Config</a></li><li class="chapter-item expanded "><a href="commands/path-setup/index.html"><strong aria-hidden="true">7.4.</strong> Path setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/path-setup/clients.html"><strong aria-hidden="true">7.4.1.</strong> Clients</a></li><li class="chapter-item expanded "><a href="commands/path-setup/connections.html"><strong aria-hidden="true">7.4.2.</strong> Connections</a></li><li class="chapter-item expanded "><a href="commands/path-setup/channels.html"><strong aria-hidden="true">7.4.3.</strong> Channels</a></li></ol></li><li class="chapter-item expanded "><a href="commands/relaying/index.html"><strong aria-hidden="true">7.5.</strong> Relaying</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/relaying/packets.html"><strong aria-hidden="true">7.5.1.</strong> Packet Messages</a></li><li class="chapter-item expanded "><a href="commands/relaying/handshakes.html"><strong aria-hidden="true">7.5.2.</strong> Handshake Messages</a></li><li class="chapter-item expanded "><a href="commands/relaying/clear.html"><strong aria-hidden="true">7.5.3.</strong> Clearing Packets</a></li></ol></li><li class="chapter-item expanded "><a href="commands/listen/index.html"><strong aria-hidden="true">7.6.</strong> Listen mode</a></li><li class="chapter-item expanded "><a href="commands/upgrade/index.html"><strong aria-hidden="true">7.7.</strong> Client upgrade</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/upgrade/test.html"><strong aria-hidden="true">7.7.1.</strong> Testing client upgrade</a></li></ol></li><li class="chapter-item expanded "><a href="commands/misbehaviour/index.html"><strong aria-hidden="true">7.8.</strong> Misbehaviour</a></li><li class="chapter-item expanded "><a href="commands/queries/index.html"><strong aria-hidden="true">7.9.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/queries/client.html"><strong aria-hidden="true">7.9.1.</strong> Client</a></li><li class="chapter-item expanded "><a href="commands/queries/connection.html"><strong aria-hidden="true">7.9.2.</strong> Connection</a></li><li class="chapter-item expanded "><a href="commands/queries/channel.html"><strong aria-hidden="true">7.9.3.</strong> Channel</a></li><li class="chapter-item expanded "><a href="commands/queries/packet.html"><strong aria-hidden="true">7.9.4.</strong> Packet</a></li><li class="chapter-item expanded "><a href="commands/queries/tx.html"><strong aria-hidden="true">7.9.5.</strong> Tx</a></li><li class="chapter-item expanded "><a href="commands/queries/transfer.html"><strong aria-hidden="true">7.9.6.</strong> Transfer</a></li></ol></li><li class="chapter-item expanded "><a href="commands/tx/index.html"><strong aria-hidden="true">7.10.</strong> Transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/tx/connection.html"><strong aria-hidden="true">7.10.1.</strong> Connection</a></li><li class="chapter-item expanded "><a href="commands/tx/channel-open.html"><strong aria-hidden="true">7.10.2.</strong> Channel Open</a></li><li class="chapter-item expanded "><a href="commands/tx/channel-close.html"><strong aria-hidden="true">7.10.3.</strong> Channel Close</a></li><li class="chapter-item expanded "><a href="commands/tx/packet.html"><strong aria-hidden="true">7.10.4.</strong> Packet</a></li><li class="chapter-item expanded "><a href="commands/tx/upgrade.html"><strong aria-hidden="true">7.10.5.</strong> Upgrade</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="help.html"><strong aria-hidden="true">8.</strong> Help</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">9.</strong> Glossary</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hermes (IBC Relayer CLI) Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hermes-guide-v100"><a class="header" href="#hermes-guide-v100">Hermes Guide (v1.0.0)</a></h1>
<p>Hermes is a an open-source Rust implementation of a relayer for the
<a href="https://ibcprotocol.org">Inter-Blockchain Communication protocol</a> (IBC).</p>
<p>This guide can help you setup, configure, and operate Hermes to transfer
packets between two or more IBC-enabled chains.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p><strong><a href="./relayer.html">What is Hermes</a></strong></p>
<ul>
<li>Explains what Hermes is about.</li>
</ul>
<p><strong><a href="./features.html">Features</a></strong></p>
<ul>
<li>This section discusses what features to expect from Hermes, as well as a
comparison between the Cosmos Go relayer and Hermes.</li>
</ul>
<p><strong><a href="./getting_started.html">Getting Started</a></strong></p>
<ul>
<li>The getting started section can help you setup, configure, and run Hermes.</li>
</ul>
<p><strong><a href="./tutorials/index.html">Tutorials</a></strong></p>
<ul>
<li>This section provides some tutorials on how to operate and test Hermes.</li>
</ul>
<p><strong><a href="./commands/index.html">Commands Reference</a></strong></p>
<ul>
<li>The commands let you interact with Hermes using its command line interface.</li>
</ul>
<p><strong><a href="./help.html">Help</a></strong></p>
<ul>
<li>This part provides guidelines regarding troubleshooting and general resources
for getting help.</li>
</ul>
<p><strong><a href="./glossary.html">Glossary</a></strong></p>
<ul>
<li>This section provides some definitions of terms used throughout the guide</li>
</ul>
<hr />
<p><strong>Other References and Useful Links:</strong></p>
<ul>
<li><a href="https://github.com/informalsystems/ibc-rs">Hermes Github repository</a>
— The official Github repository for Hermes.</li>
<li><a href="https://github.com/cosmos/ics">IBC Github repository</a>
<ul>
<li>The official repository for the Inter-blockchain protocol (IBC).</li>
</ul>
</li>
</ul>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>This project is undergoing heavy development, use at your own risk.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-hermes"><a class="header" href="#what-is-hermes">What is Hermes?</a></h1>
<p>Hermes is an open-source Rust implementation of a relayer for the
<a href="https://ibc.cosmos.network">Inter-Blockchain Communication protocol</a> (IBC),
released under the <a href="https://crates.io/crates/ibc-relayer-cli">ibc-relayer-cli</a> crate.</p>
<p>The <strong>Inter-Blockchain Communication protocol</strong> is an end-to-end, connection-oriented,
stateful protocol for reliable, ordered, and authenticated communication between modules
on separate distributed ledgers. <sup class="footnote-reference"><a href="#ibc">1</a></sup></p>
<p>An IBC <strong>relayer</strong> is an off-chain process responsible for relaying IBC messages between any two chains.
The way it does so is by scanning chain states, building transactions based on these states,
and submitting the transactions to the chains involved in the network.</p>
<p>The relayer is a central element in the IBC network architecture. This is because chain modules
in this architecture are not directly sending messages to each other over networking infrastructure,
but instead they create and store the data to be retrieved and used by a relayer to build the IBC messages.</p>
<p>We sometimes refer to Hermes as &quot;IBC Relayer CLI&quot;, to make it clear that this
is a relayer CLI (i.e., a binary) and distinguish it from the relayer core library
(that is the crate called <a href="https://crates.io/crates/ibc-relayer"><code>ibc-relayer</code></a>).</p>
<p>Hermes is actively developed and maintained by <a href="https://informal.systems">Informal Systems</a> in the <a href="https://github.com/informalsystems/ibc-rs">ibc-rs</a> repository.</p>
<div class="footnote-definition" id="ibc"><sup class="footnote-definition-label">1</sup>
<p><a href="https://arxiv.org/pdf/2006.15918.pdf">The Interblockchain Communication Protocol: An Overview</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>This section includes a summary of the supported and planned features.
A feature matrix and comparison between the Rust and Go relayer implementations can be found in the <a href="./features/matrix.html">Feature Matrix</a></p>
<blockquote>
<p><strong>Cosmos SDK &amp; IBC compatibility:</strong>
Hermes supports Cosmos SDK chains implementing the <a href="https://github.com/cosmos/ibc">IBC protocol v1</a> protocol specification.
Cosmos SDK versions <code>0.41.3</code> through <code>0.45.x</code> are officially supported.
IBC-go versions <code>1.1.*</code> thorough <code>3.*</code> are officially supported.
In case Hermes finds an incompatible SDK or IBC-go version, it will output a log warning upon initialization as part of the <code>start</code> command or upon <code>health-check</code> command.</p>
</blockquote>
<h2 id="supported-features"><a class="header" href="#supported-features">Supported Features</a></h2>
<ul>
<li>Basic features
<ul>
<li>create and update clients</li>
<li>refresh clients to prevent expiration</li>
<li>establish connections with new or existing clients</li>
<li>establish channels with new or existing connection</li>
<li>channel closing handshake</li>
<li>relay packets, acknowledgments, timeout and timeout-on-close packets, with zero or non-zero delay.</li>
<li>queries for all objects</li>
</ul>
</li>
<li>Packet relaying over:
<ul>
<li>multiple paths, for the chains in <code>config.toml</code></li>
</ul>
</li>
<li>Restart support
<ul>
<li>clear packets</li>
<li>resume channel handshake if configured to relay <code>all</code></li>
<li>resume connection handshake if configured to relay <code>all</code></li>
</ul>
</li>
<li>Client upgrade
<ul>
<li>upgrading clients after a counterparty chain has performed an upgrade for IBC breaking changes</li>
</ul>
</li>
<li>Packet delay:
<ul>
<li>establish path over non-zero delay connection</li>
<li>relay all packets with the specified delay</li>
</ul>
</li>
<li>Interchain Accounts &amp; Interchain Security</li>
<li>Monitor and submit misbehaviour for clients
<ul>
<li>monitor client updates for misbehaviour (fork and BFT time violation)</li>
<li>submit misbehaviour evidence to the on-chain IBC client.</li>
</ul>
<blockquote>
<p>misbehaviour submission to full node not yet supported</p>
</blockquote>
</li>
<li>Individual commands that build and send transactions for:
<ul>
<li>creating and updating IBC Tendermint light clients</li>
<li>sending connection open handshake messages</li>
<li>sending channel open handshake messages</li>
<li>sending channel closing handshake messages</li>
<li>initiating a cross chain transfer (mainly for testing)</li>
<li>relaying sent packets, acknowledgments and timeouts</li>
<li>client upgrade</li>
</ul>
</li>
<li>Channel handshake for existing channel that is not in <code>Open</code> state</li>
<li>Connection handshake for existing connection that is not in <code>Open</code> state</li>
<li>Telemetry support</li>
</ul>
<h2 id="upcoming--unsupported-features"><a class="header" href="#upcoming--unsupported-features">Upcoming / Unsupported Features</a></h2>
<p>Planned features:</p>
<ul>
<li>Interchain Queries</li>
<li>Non-SDK support</li>
<li>Relay from all IBC events, including governance upgrade proposal</li>
<li>Dynamic &amp; automatic configuration management</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-matrix"><a class="header" href="#feature-matrix">Feature Matrix</a></h1>
<p>This section gives more details about the features and implementation status 
of Hermes in comparison with the <a href="https://github.com/cosmos/relayer">cosmos-go-relayer</a>.</p>
<p><strong>Legend</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Term</th><th>Description</th></tr></thead><tbody>
<tr><td>❌</td><td>feature not supported</td></tr>
<tr><td>✅</td><td>feature is supported</td></tr>
<tr><td><code>Chain</code></td><td>chain related</td></tr>
<tr><td><code>Cl</code></td><td>client related</td></tr>
<tr><td><code>Conn</code></td><td>connection related</td></tr>
<tr><td><code>Chan</code></td><td>channel related</td></tr>
<tr><td><code>Cfg</code></td><td>config related</td></tr>
<tr><td><code>.._Handshake_..</code></td><td>can execute all transactions required to finish a handshake from a single command</td></tr>
<tr><td><code>.._&lt;msg&gt;_A</code></td><td>building and sending <code>msg</code> from a command that scans chain state</td></tr>
<tr><td><code>.._&lt;msg&gt;_P</code></td><td>building and sending <code>msg</code> from IBC event; doesn't apply to <code>.._Init</code> and <code>FT_Transfer</code> features</td></tr>
</tbody></table>
</div>
<p><strong>Feature comparison between Hermes and the Go relayer</strong> </p>
<div class="table-wrapper"><table><thead><tr><th>Features \      Status</th><th style="text-align: center">Hermes</th><th style="text-align: center">Cosmos Go</th><th style="text-align: left">Feature Details</th></tr></thead><tbody>
<tr><td>Restart</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">replays any IBC events that happened before restart</td></tr>
<tr><td>Multiple_Paths</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">relays on multiple paths concurrently</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Connection Delay</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td>Cl_Misbehavior</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left">monitors and submits IBC client misbehavior</td></tr>
<tr><td>Cl_Refresh</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left">periodically refresh an on-chain client to prevent expiration</td></tr>
<tr><td>Packet Delay</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Chan_Unordered</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Ordered</td><td style="text-align: center">✅</td><td style="text-align: center">❓</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Cl_Tendermint_Create</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">tendermint light client creation</td></tr>
<tr><td>Cl_Tendermint_Update</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">tendermint light client update</td></tr>
<tr><td>Cl_Tendermint_Upgrade</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">tendermint light client upgrade</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Conn_Open_Handshake_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Conn_Open_Handshake_P</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Chan_Open_Handshake_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Open_Handshake_P</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Open_Handshake_Optimistic</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">open a channel on a non-Open connection</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Chan_Close_Handshake_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Close_Handshake_A</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>FT_Transfer</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">can submit an ICS-20 fungible token transfer message</td></tr>
<tr><td>ICA_Relay</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left">can relay ICS-27 Interchain account packets</td></tr>
<tr><td>Packet_Recv_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Recv_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Timeout_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Timeout_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_TimeoutClose_A</td><td style="text-align: center">✅</td><td style="text-align: center">❓</td><td style="text-align: left"></td></tr>
<tr><td>Packet_TimeoutClose_P</td><td style="text-align: center">✅</td><td style="text-align: center">❓</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Optimistic</td><td style="text-align: center">❌</td><td style="text-align: center">❓</td><td style="text-align: left">relay packets over non-Open channels</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Cl_Non_Tendermint</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">supports non tendermint IBC light clients</td></tr>
<tr><td>Chain_Non_Cosmos</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">supports non cosmos-SDK chains</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Cfg_Static</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">provides means for configuration prior to being started</td></tr>
<tr><td>Cfg_Dynamic</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">provides means for configuration and monitoring during runtime</td></tr>
<tr><td>Cfg_Download_Config</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: left">provides means for downloading recommended configuration</td></tr>
<tr><td>Cfg_Edit_Config</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: left">provides means for editing the configuration from the CLI</td></tr>
<tr><td>Cfg_Validation</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">provides means to validate the current configuration</td></tr>
<tr><td>Telemetry</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left">telemetry server to collect metrics</td></tr>
<tr><td>REST API</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left">REST API to interact with the relayer</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In order to run Hermes, please make sure you have all the 
<a href="./pre_requisites.html">pre-requisites</a> installed on your machine.</p>
<p>Once you have these pre-requisites, you can
<a href="./installation.html">build and run Hermes</a>.</p>
<blockquote>
<p>The instructions in this guide have been tested on <code>Linux</code> and <code>MacOS</code> 
environments. Most of the commands should work on both environments. Even 
though you can build and run the relayer on <code>Windows</code> (since we develop it 
in Rust and it supports cross platform compilation) we have not tested the 
relayer on <code>Windows</code> and we do not support this operating system at this time.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-requisites"><a class="header" href="#pre-requisites">Pre-requisites</a></h1>
<h2 id="1-rust"><a class="header" href="#1-rust">1. Rust</a></h2>
<p>The IBC Relayer is developed with the <a href="https://www.rust-lang.org">Rust</a> programming language. In order to build and run the relayer you need to install and configure <code>Rust</code> on your machine.</p>
<h3 id="fresh-rust-installation"><a class="header" href="#fresh-rust-installation">Fresh Rust installation</a></h3>
<p>For instructions on how to install <code>Rust</code> on your machine please follow the official <a href="https://www.rust-lang.org/tools/install"><code>Notes about Rust Installation</code></a>.</p>
<p>The provided instructions will install all the Rust toolchain including <code>rustc</code>, <code>cargo</code>, and <code>rustup</code> that are required to build the project.</p>
<h3 id="version-requirements"><a class="header" href="#version-requirements">Version requirements</a></h3>
<p>Hermes is developed and tested using the latest version of Rust, <code>1.60</code> at
the moment. To check that your toolchain is up-to-date run:</p>
<pre><code class="language-shell">rustc --version
</code></pre>
<p>In case you already had installed the Rust toolchain in the past, you can
update your installation by running <code>rustup update</code>.</p>
<h3 id="testing-the-installation"><a class="header" href="#testing-the-installation">Testing the installation</a></h3>
<p>After you install the <code>Rust</code> toolchain you can execute the following command:</p>
<pre><code class="language-shell">cargo version
</code></pre>
<p>This should display the <code>cargo</code> version and confirm the proper installation.</p>
<h2 id="2-golang"><a class="header" href="#2-golang">2. Golang</a></h2>
<p>You will also need the <strong>Go</strong> programming language installed and configured on your machine. This is a requirement for the the section <a href="./tutorials/local-chains/gaia.html">Installing Gaia</a> in the <a href="./tutorials/local-chains/index.html">Two Local Chains</a> tutorial.</p>
<p>To install and configure Golang on your machine please follow the <a href="https://golang.org/doc/install">Golang official documentation</a>.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Next, go to the <a href="./installation.html">Installation</a> section to learn how to build Hermes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-the-relayer"><a class="header" href="#install-the-relayer">Install the relayer</a></h1>
<p>There are two main approaches for obtaining Hermes:</p>
<ol>
<li>
<p>Installation:</p>
<ol>
<li>If you are running on a Unix machine (Linux/MacOS), then the simplest
option is to <a href="installation.html#install-by-downloading">download the latest binary</a>.</li>
<li>You can also install via <a href="installation.html#install-via-cargo">Cargo</a>.</li>
</ol>
</li>
<li>
<p>Alternatively, <a href="installation.html#build-from-source">build Hermes directly from source</a>.</p>
</li>
</ol>
<h2 id="install-by-downloading"><a class="header" href="#install-by-downloading">Install by downloading</a></h2>
<p>Simply head to the GitHub <a href="https://github.com/informalsystems/ibc-rs/releases">Releases</a> page and download the latest
version of Hermes binary matching your platform:</p>
<ul>
<li>MacOS: <code>hermes-v1.0.0-x86_64-apple-darwin.tar.gz</code> (or .zip),</li>
<li>Linux: <code>hermes-v1.0.0-x86_64-unknown-linux-gnu.tar.gz</code> (or .zip).</li>
</ul>
<p>The step-by-step instruction below should carry you through the whole process:</p>
<ol>
<li>
<p>Make the directory where we'll place the binary:</p>
<pre><code class="language-shell">mkdir -p $HOME/.hermes/bin
</code></pre>
</li>
<li>
<p>Extract the binary archive:</p>
<pre><code class="language-shell">tar -C $HOME/.hermes/bin/ -vxzf $ARCHIVE_NAME
</code></pre>
</li>
<li>
<p>Update your path, by adding this line in your <code>.bashrc</code> or <code>.zshrc</code> shell
configuration file:</p>
<pre><code class="language-shell">export PATH=&quot;$HOME/.hermes/bin:$PATH&quot;
</code></pre>
</li>
</ol>
<blockquote>
<p>NOTE: The binary may be initially prevented from running if you're
on MacOS.
See the <a href="https://support.apple.com/en-gb/HT202491">&quot;Open Anyway&quot; instructions from this support forum</a>
if that is the case.</p>
</blockquote>
<p>You should now be able to run Hermes by invoking the <code>hermes</code> executable.</p>
<pre><code class="language-shell">hermes version
</code></pre>
<pre><code>hermes v1.0.0
</code></pre>
<h2 id="install-via-cargo"><a class="header" href="#install-via-cargo">Install via Cargo</a></h2>
<blockquote>
<p>NOTE: This approach assumes you have installed all
the <a href="./pre_requisites.html">pre-requisites</a> on your machine.</p>
</blockquote>
<p>Hermes is packaged in the <code>ibc-relayer-cli</code> Rust crate.
To install the latest release of Hermes, run the following command in a terminal:</p>
<pre><code class="language-shell">cargo install ibc-relayer-cli@1.0.0 --bin hermes --locked
</code></pre>
<p>This will download and build the crate <code>ibc-relayer-cli</code>, and install the
<code>hermes</code> binary in <code>$HOME/.cargo/bin</code>.</p>
<blockquote>
<p>If you have not installed Rust and Cargo via <a href="https://rustup.rs">rustup.rs</a>, you may need to
add the <code>$HOME/.cargo/bin</code> directory to your <code>PATH</code> environment variable.
For most shells, this can be done by adding the following line to your
<code>.bashrc</code> or <code>.zshrc</code> configuration file:</p>
<pre><code class="language-shell">export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
</blockquote>
<p>You should now be able to run Hermes by invoking the <code>hermes</code> executable.</p>
<pre><code class="language-shell">hermes version
</code></pre>
<pre><code>hermes v1.0.0
</code></pre>
<h2 id="build-from-source"><a class="header" href="#build-from-source">Build from source</a></h2>
<h3 id="clone-the-repository"><a class="header" href="#clone-the-repository">Clone the repository</a></h3>
<p>Open a terminal and clone the <code>ibc-rs</code> repository:</p>
<pre><code class="language-shell">git clone https://github.com/informalsystems/ibc-rs.git
</code></pre>
<p>Change to the repository directory</p>
<pre><code class="language-shell">cd ibc-rs
</code></pre>
<h3 id="checkout-the-latest-release"><a class="header" href="#checkout-the-latest-release">Checkout the latest release</a></h3>
<p>Go to the <a href="https://github.com/informalsystems/ibc-rs/releases">ibc-rs releases</a> page to see what is the most recent release.</p>
<p>Then checkout the release, for example if the most recent release is <code>v1.0.0</code> then execute the command:</p>
<pre><code class="language-shell">git checkout v1.0.0
</code></pre>
<h3 id="building-with-cargo-build"><a class="header" href="#building-with-cargo-build">Building with <code>cargo build</code></a></h3>
<p>This command builds all the crates from the <a href="https://github.com/informalsystems/ibc-rs"><strong><code>ibc-rs</code></strong></a> repository, namely: the <a href="https://github.com/informalsystems/ibc-rs/tree/master/modules"><strong><code>ibc</code></strong></a> modules crate, <a href="https://github.com/informalsystems/ibc-rs/tree/master/relayer"><strong><code>ibc-relayer</code></strong></a> crate, <a href="https://github.com/informalsystems/ibc-rs/tree/master/proto"><strong><code>ibc-proto</code></strong></a> crate, and the <a href="https://github.com/informalsystems/ibc-rs/tree/master/relayer-cli"><strong><code>ibc-relayer-cli</code></strong></a> crate.
The last of these crates contains the <code>hermes</code> binary.</p>
<pre><code class="language-shell">cargo build --release --bin hermes
</code></pre>
<p><a name="telemetry-support"></a></p>
<blockquote>
<p>By default, Hermes bundles a <a href="./telemetry.html">telemetry service and server</a>.
To build Hermes without telemetry support, and get a smaller executable,
supply the <code>--no-default-features flag</code> to <code>cargo build</code>:</p>
<pre><code class="language-shell">cargo build --release --no-default-features --bin hermes
</code></pre>
</blockquote>
<p>If the build is successful, the <code>hermes</code> executable will be located in the following location:</p>
<pre><code class="language-shell">./target/release/hermes
</code></pre>
<p><strong>Troubleshooting</strong>:
In case the <code>cargo build</code> command above fails, as a first course of action we
recommend trying to run the same command with the additional <code>locked</code> flag:</p>
<pre><code class="language-shell">cargo build --release --bin hermes --locked
</code></pre>
<h3 id="running-for-the-first-time"><a class="header" href="#running-for-the-first-time">Running for the first time</a></h3>
<p>If you run the <code>hermes</code> without any additional parameters you should see the usage and help information:</p>
<pre><code class="language-shell">./target/release/hermes
</code></pre>
<pre><code>hermes v1.0.0
Informal Systems &lt;hello@informal.systems&gt;

USAGE:
    hermes [OPTIONS] &lt;SUBCOMMAND&gt;

OPTIONS:
        --config &lt;CONFIG&gt;    Path to configuration file
    -h, --help               Print help information
        --json               Enable JSON output
    -V, --version            Print version information

SUBCOMMANDS:
    clear           Clear objects, such as outstanding packets on a channel
    config          Validate Hermes configuration file
    create          Create objects (client, connection, or channel) on chains
    health-check    Performs a health check of all chains in the the config
    help            Print this message or the help of the given subcommand(s)
    keys            Manage keys in the relayer for each chain
    listen          Listen to and display IBC events emitted by a chain
    misbehaviour    Listen to client update IBC events and handles misbehaviour
    query           Query objects from the chain
    start           Start the relayer in multi-chain mode
    tx              Create and send IBC transactions
    update          Update objects (clients) on chains
    upgrade         Upgrade objects (clients) after chain upgrade
    completions     Generate auto-complete scripts for different shells
</code></pre>
<h3 id="creating-an-alias-for-the-executable"><a class="header" href="#creating-an-alias-for-the-executable">Creating an alias for the executable</a></h3>
<p>It might be easier to create an alias for <code>hermes</code> so you can just run it by specifying the executable name instead of the whole path. In order to create an alias execute the following command:</p>
<pre><code class="language-shell">alias hermes='cargo run --release --bin hermes --'
</code></pre>
<h2 id="shell-auto-completions"><a class="header" href="#shell-auto-completions">Shell auto-completions</a></h2>
<p>The <code>completions</code> subcommand of Hermes can be used to output a completion script
for a choice of widely used command-line shells.
Refer to <code>hermes completions --help</code> for the list. Some shell-specific examples
of setting up auto-completion with this command are provided below; check your
shell configuration to decide on the suitable directory in which to install the script
and any further necessary modifications to the shell's startup files.</p>
<h3 id="bash"><a class="header" href="#bash">Bash</a></h3>
<pre><code class="language-sh">hermes completions --shell bash &gt; ~/.local/share/bash-completion/completions/hermes
</code></pre>
<p>On a MacOS installation with Homebrew <code>bash-completion</code> formula installed, use </p>
<pre><code class="language-sh">hermes completions --shell bash &gt; $(brew --prefix)/etc/bash_completion.d/hermes.bash-completion
</code></pre>
<h3 id="zsh"><a class="header" href="#zsh">Zsh</a></h3>
<pre><code class="language-sh">hermes completions --shell zsh &gt; ~/.zfunc/_hermes
</code></pre>
<p>To make the shell load the script on initialization, add the directory to <code>fpath</code>
in your <code>~/.zshrc</code> before <code>compinit</code>:</p>
<pre><code>fpath+=~/.zfunc
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Go to the <a href="./config.html"><code>Configuration</code></a> section to learn how to create a configuration file to be used by Hermes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>In order to run Hermes, you will need to have a configuration file.</p>
<p>The format supported for the configuration file is <a href="https://toml.io/en/">TOML</a>.</p>
<p>By default, Hermes expects the configuration file to be located at <code>$HOME/.hermes/config.toml</code>.</p>
<p>This can be overridden by supplying the <code>--config</code> flag when invoking <code>hermes</code>, before the
name of the command to run, eg. <code>hermes --config my_config.toml query connection channels --chain ibc-1 --connection connection-1</code>.</p>
<blockquote>
<p>The current version of Hermes does not support managing the configuration file programmatically.
You will need to use a text editor to create the file and add content to it.</p>
</blockquote>
<pre><code class="language-bash">hermes [--config CONFIG_FILE] COMMAND
</code></pre>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="config.html#configuration">Configuration</a></li>
<li><a href="config.html#adding-private-keys">Adding private keys</a></li>
<li><a href="config.html#connecting-via-tls">Connecting via TLS</a></li>
<li><a href="config.html#support-for-interchain-accounts">Support for Interchain Accounts</a></li>
<li><a href="config.html#next-steps">Next steps</a></li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>The configuration file must have one <code>global</code> section, and one <code>chains</code> section for each chain.</p>
<blockquote>
<p><strong>Note:</strong> As of 0.6.0, the Hermes configuration file is self-documented.
Please read the configuration file <a href="https://github.com/informalsystems/ibc-rs/blob/v1.0.0/config.toml"><code>config.toml</code></a>
itself for the most up-to-date documentation of parameters.</p>
</blockquote>
<p>By default, Hermes will relay on all channels available between all the configured chains.
In this way, every configured chain will act as a source (in the sense that Hermes listens for events)
and as a destination (to relay packets that others chains have sent).</p>
<p>For example, if there are only two chains configured, then Hermes will only relay packets between those two,
i.e. the two chains will serve as a source for each other, and likewise as a destination for each other's relevant events.
Hermes will ignore all events that pertain to chains which are unknown (ie. not present in config.toml).</p>
<p>To restrict relaying on specific channels, or uni-directionally, you can use <a href="https://github.com/informalsystems/ibc-rs/blob/v1.0.0/config.toml#L209-L231">packet filtering policies</a>.</p>
<h2 id="adding-private-keys"><a class="header" href="#adding-private-keys">Adding private keys</a></h2>
<p>For each chain configured you need to add a private key for that chain in order to submit <a href="./commands/tx/index.html">transactions</a>,
please refer to the <a href="./commands/keys/index.html">Keys</a> sections in order to learn how to add the private keys that are used by the relayer.</p>
<h2 id="connecting-via-tls"><a class="header" href="#connecting-via-tls">Connecting via TLS</a></h2>
<p>Hermes supports connection via TLS for use-cases such as connecting from behind
a proxy or a load balancer. In order to enable this, you'll want to set the
<code>rpc_addr</code>, <code>grpc_addr</code>, or <code>websocket_addr</code> parameters to specify a TLS
connection via HTTPS using the following scheme (note that the port number 443
is just used for example):</p>
<pre><code>rpc_addr = 'https://domain.com:443'
grpc_addr = 'https://domain.com:443'
websocket_addr = 'wss://domain.com:443/websocket'
</code></pre>
<h2 id="support-for-interchain-accounts"><a class="header" href="#support-for-interchain-accounts">Support for Interchain Accounts</a></h2>
<p>As of version 0.13.0, Hermes supports relaying on <a href="https://github.com/cosmos/ibc/blob/master/spec/app/ics-027-interchain-accounts/README.md">Interchain Accounts</a> channels.</p>
<p>If the <code>packet_filter</code> option in the chain configuration is disabled, then
Hermes will relay on all existing and future channels, including ICA channels.</p>
<p>There are two kinds of ICA channels:</p>
<ol>
<li>The host channels, whose port is <code>icahost</code></li>
<li>The controller channels, whose port starts with <code>icacontroller-</code> followed
by the owner account address. <a href="https://github.com/cosmos/ibc/blob/master/spec/app/ics-027-interchain-accounts/README.md">See the spec for more details</a>.</li>
</ol>
<p>If you wish to only relay on a few specific standard channels (here <code>channel-0</code> and <code>channel-1</code>),
but also relay on all ICA channels, you can specify the following packet filter:</p>
<blockquote>
<p>Note the use of wildcards in the port and channel identifiers (<code>['ica*', '*']</code>)
to match over all the possible ICA ports.</p>
</blockquote>
<pre><code class="language-toml">[chains.packet_filter]
policy = 'allow'
list = [
  ['ica*', '*'], # allow relaying on all channels whose port starts with `ica`
  ['transfer', 'channel-0'],
  ['transfer', 'channel-1'],
  # Add any other port/channel pairs you wish to relay on
]
</code></pre>
<p>If you wish to relay on all channels but not on ICA channels, you can use
the following packet filter configuration:</p>
<pre><code class="language-toml">[chains.packet_filter]
policy = 'deny'
list = [
  ['ica*', '*'], # deny relaying on all channels whose port starts with `ica`
]
</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next steps</a></h2>
<p>Now that you learned how to build the relayer and how to create a configuration file, you can go to the <a href="./tutorials/local-chains/index.html"><code>Two Chains</code></a> tutorial to learn how to perform some local testing connecting the relayer to two local chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-configuration-file"><a class="header" href="#example-configuration-file">Example Configuration File</a></h1>
<p>Here is a full example of a configuration file with two chains configured:</p>
<pre><code class="language-toml"># The global section has parameters that apply globally to the relayer operation.
[global]

# Specify the verbosity for the relayer logging output. Default: 'info'
# Valid options are 'error', 'warn', 'info', 'debug', 'trace'.
log_level = 'info'


# Specify the mode to be used by the relayer. [Required]
[mode]

# Specify the client mode.
[mode.clients]

# Whether or not to enable the client workers. [Required]
enabled = true

# Whether or not to enable periodic refresh of clients. [Default: true]
# This feature only applies to clients that underlie an open channel.
# For Tendermint clients, the frequency at which Hermes refreshes them is 2/3 of their
# trusting period (e.g., refresh every ~9 days if the trusting period is 14 days).
# Note: Even if this is disabled, clients will be refreshed automatically if
#      there is activity on a connection or channel they are involved with.
refresh = true

# Whether or not to enable misbehaviour detection for clients. [Default: false]
misbehaviour = false

# Specify the connections mode.
[mode.connections]

# Whether or not to enable the connection workers for handshake completion. [Required]
enabled = false

# Specify the channels mode.
[mode.channels]

# Whether or not to enable the channel workers for handshake completion. [Required]
enabled = false

# Specify the packets mode.
[mode.packets]

# Whether or not to enable the packet workers. [Required]
enabled = true

# Parametrize the periodic packet clearing feature.
# Interval (in number of blocks) at which pending packets
# should be periodically cleared. A value of '0' will disable
# periodic packet clearing. [Default: 100]
clear_interval = 100

# Whether or not to clear packets on start. [Default: false]
clear_on_start = true

# Toggle the transaction confirmation mechanism.
# The tx confirmation mechanism periodically queries the `/tx_search` RPC
# endpoint to check that previously-submitted transactions
# (to any chain in this config file) have been successfully delivered.
# If they have not been, and `clear_interval = 0`, then those packets are
# queued up for re-submission.
# If set to `false`, the following telemetry metrics will be disabled:
# `acknowledgment_packets_confirmed`, `receive_packets_confirmed` and `timeout_packets_confirmed`.
# [Default: false]
tx_confirmation = false

# The REST section defines parameters for Hermes' built-in RESTful API.
# https://hermes.informal.systems/rest.html
[rest]

# Whether or not to enable the REST service. Default: false
enabled = true

# Specify the IPv4/6 host over which the built-in HTTP server will serve the RESTful
# API requests. Default: 127.0.0.1
host = '127.0.0.1'

# Specify the port over which the built-in HTTP server will serve the restful API
# requests. Default: 3000
port = 3000


# The telemetry section defines parameters for Hermes' built-in telemetry capabilities.
# https://hermes.informal.systems/telemetry.html
[telemetry]

# Whether or not to enable the telemetry service. Default: false
enabled = false

# Specify the IPv4/6 host over which the built-in HTTP server will serve the metrics
# gathered by the telemetry service. Default: 127.0.0.1
host = '127.0.0.1'

# Specify the port over which the built-in HTTP server will serve the metrics gathered
# by the telemetry service. Default: 3001
port = 3001


# A chains section includes parameters related to a chain and the full node to which
# the relayer can send transactions and queries.
[[chains]]

# Specify the chain ID. Required
id = 'ibc-0'

# Specify the RPC address and port where the chain RPC server listens on. Required
rpc_addr = 'http://127.0.0.1:26657'

# Specify the GRPC address and port where the chain GRPC server listens on. Required
grpc_addr = 'http://127.0.0.1:9090'

# Specify the WebSocket address and port where the chain WebSocket server
# listens on. Required
websocket_addr = 'ws://127.0.0.1:26657/websocket'

# Specify the maximum amount of time (duration) that the RPC requests should
# take before timing out. Default: 10s (10 seconds)
# Note: Hermes uses this parameter _only_ in `start` mode; for all other CLIs,
# Hermes uses a large preconfigured timeout (on the order of minutes).
rpc_timeout = '10s'

# Specify the prefix used by the chain. Required
account_prefix = 'cosmos'

# Specify the name of the private key to use for signing transactions. Required
# See the Adding Keys chapter for more information about managing signing keys:
#   https://hermes.informal.systems/commands/keys/index.html#adding-keys
key_name = 'testkey'

# Specify the address type which determines:
# 1) address derivation;
# 2) how to retrieve and decode accounts and pubkeys;
# 3) the message signing method.
# The current configuration options are for Cosmos SDK and Ethermint.
#
# Example configuration for chains based on Ethermint library:
#
# address_type = { derivation = 'ethermint', proto_type = { pk_type = '/ethermint.crypto.v1.ethsecp256k1.PubKey' } }
#
# Default: { derivation = 'cosmos' }, i.e. address derivation as in Cosmos SDK.
# Warning: This is an advanced feature! Modify with caution.
address_type = { derivation = 'cosmos' }

# Specify the store prefix used by the on-chain IBC modules. Required
# Recommended value for Cosmos SDK: 'ibc'
store_prefix = 'ibc'

# Specify the default amount of gas to be used in case the tx simulation fails,
# and Hermes cannot estimate the amount of gas needed.
# Default: 100 000
default_gas = 100000

# Specify the maximum amount of gas to be used as the gas limit for a transaction.
# If `default_gas` is unspecified, then `max_gas` will be used as `default_gas`.
# Default: 400 000
max_gas = 400000

# Specify the price per gas used of the fee to submit a transaction and
# the denomination of the fee. Required
gas_price = { price = 0.001, denom = 'stake' }

# Multiply this amount with the gas estimate, used to compute the fee
# and account for potential estimation error.
#
# Example: With this setting set to 1.1, then if the estimated gas
# is 80_000, then gas used to compute the fee will be adjusted to
# 80_000 * 1.1 = 88_000.
#
# Default: 1.1, ie. the gas is increased by 10%
# Minimum value: 1.0
gas_multiplier = 1.1

# Specify how many IBC messages at most to include in a single transaction.
# Default: 30
max_msg_num = 30

# Specify the maximum size, in bytes, of each transaction that Hermes will submit.
# Default: 2097152 (2 MiB)
max_tx_size = 2097152

# Specify the maximum amount of time to tolerate a clock drift.
# The clock drift parameter defines how much new (untrusted) header's time
# can drift into the future. Default: 5s
clock_drift = '5s'

# Specify the maximum time per block for this chain.
# The block time together with the clock drift are added to the source drift to estimate
# the maximum clock drift when creating a client on this chain. Default: 30s
# For cosmos-SDK chains a good approximation is `timeout_propose` + `timeout_commit`
# Note: This MUST be the same as the `max_expected_time_per_block` genesis parameter for Tendermint chains.
max_block_time = '30s'

# Specify the amount of time to be used as the light client trusting period.
# It should be significantly less than the unbonding period
# (e.g. unbonding period = 3 weeks, trusting period = 2 weeks).
# Default: 2/3 of the `unbonding period` for Cosmos SDK chains
trusting_period = '14days'

# Specify the trust threshold for the light client, ie. the maximum fraction of validators
# which have changed between two blocks.
# Default: { numerator = '1', denominator = '3' }, ie. 1/3.
# Warning: This is an advanced feature! Modify with caution.
trust_threshold = { numerator = '1', denominator = '3' }

# Specify a string that Hermes will use as a memo for each transaction it submits
# to this chain. The string is limited to 50 characters. Default: '' (empty).
# Note: Hermes will append to the string defined here additional
# operational debugging information, e.g., relayer build version.
memo_prefix = ''

# This section specifies the filters for policy based relaying.
#
# Default: no policy / filters, allow all packets on all channels.
#
# Only packet filtering based on channel identifier can be specified.
# A channel filter has two fields:
# 1. `policy` - one of two types are supported:
#       - 'allow': permit relaying _only on_ the port/channel id in the list below,
#       - 'deny': permit relaying on any channel _except for_ the list below.
# 2. `list` - the list of channels specified by the port and channel identifiers.
#             Optionally, each element may also contains wildcards, for eg. 'ica*'
#             to match all identifiers starting with 'ica' or '*' to match all identifiers.
#
# Example configuration of a channel filter, only allowing packet relaying on
# channel with port ID 'transfer' and channel ID 'channel-0', as well as on
# all ICA channels.
#
# [chains.packet_filter]
# policy = 'allow'
# list = [
#   ['ica*', '*'],
#   ['transfer', 'channel-0'],
# ]

# Specify that the transaction fees should be payed from this fee granter's account.
# Optional. If unspecified (the default behavior), then no fee granter is used, and
# the account specified in `key_name` will pay the tx fees for all transactions
# submitted to this chain.
# fee_granter = ''

[[chains]]
id = 'ibc-1'
rpc_addr = 'http://127.0.0.1:26557'
grpc_addr = 'http://127.0.0.1:9091'
websocket_addr = 'ws://127.0.0.1:26557/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
default_gas = 100000
max_gas = 400000
gas_price = { price = 0.001, denom = 'stake' }
gas_multiplier = 1.1
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '1', denominator = '3' }
address_type = { derivation = 'cosmos' }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telemetry"><a class="header" href="#telemetry">Telemetry</a></h1>
<p>To gain a better understanding of the status and activity of the relayer,
Hermes features a built-in telemetry service based on the <a href="https://opentelemetry.io">OpenTelemetry</a> observability framework,
whose metrics can be exposed over HTTP for integration with the <a href="https://prometheus.io">Prometheus</a> monitoring system.</p>
<p>The official Hermes builds for Linux and macOS come with telemetry support since version <code>v0.4.0</code>.
See the <a href="installation.html#install-the-relayer">installation instructions</a> for how to obtain the latest version of Hermes.</p>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>The telemetry service is not active by default, and must be enabled in the relayer configuration:</p>
<pre><code class="language-toml">[telemetry]
enabled = true          # default = false
host    = '127.0.0.1'   # default value
port    = 3001          # default value
</code></pre>
<p>Please see the <a href="./config.html">relevant section for <em>Configuration</em></a> for more general details about Hermes configuration options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hermes-operators-guide-to-using-metrics"><a class="header" href="#hermes-operators-guide-to-using-metrics">Hermes operators guide to using metrics</a></h1>
<p>This section is a basic guide on how Hermes metrics can be used to observe both
the current state of the Hermes relayer and the networks it is connected to.</p>
<h2 id="general-remarks-about-the-metrics"><a class="header" href="#general-remarks-about-the-metrics">General remarks about the metrics</a></h2>
<ul>
<li>All Hermes metrics are tracked and updated from the moment the Hermes service (i.e., <code>start</code>) starts up.
Metrics are automatically reset if the service is restarted.</li>
<li>For maximum reliability, it is advised to combine monitoring of your Hermes service with monitoring of your full nodes.</li>
<li>Some metrics require specific configurations to be enabled, this is described in the <code>Configuration Dependencies</code> column.</li>
</ul>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<p>Hermes metrics are designed to be able to answer four basic questions:</p>
<ol>
<li>Is Hermes active (i.e., <em>submitting</em> any transactions to any network)?</li>
<li>Are Hermes transactions successful (i.e., <em>confirmed</em> and included in the network)?</li>
<li>What is the overall IBC status of each network?</li>
<li>How efficient and how secure is the IBC status on each network?</li>
</ol>
<p>For each of this question, there is a dedicated sub-section:</p>
<ul>
<li><a href="telemetry/operators.html#is-hermes-active">Is Hermes active?</a></li>
<li><a href="telemetry/operators.html#are-hermes-transactions-successful">Are Hermes transactions successful?</a></li>
<li><a href="telemetry/operators.html#what-is-the-overall-ibc-status-of-each-network">What is the overall IBC status of each network?</a></li>
<li><a href="telemetry/operators.html#how-efficient-and-how-secure-is-the-ibc-status-on-each-network">How efficient and how secure is the IBC status on each network?</a></li>
</ul>
<h2 id="is-hermes-active"><a class="header" href="#is-hermes-active">Is Hermes active?</a></h2>
<p>By <em>active</em> we mean specifically: is Hermes <em>submitting</em> any transactions to any network?
The metrics in the table below are design to answer this question on multiple dimensions.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>workers</code></td><td>Number of workers per type</td><td><code>i64</code> UpDownCounter</td><td>Corresponding workers enabled</td></tr>
<tr><td><code>client_updates_submitted</code></td><td>Number of client update messages submitted, per sending chain, receiving chain and client</td><td><code>u64</code> Counter</td><td>Client, Connection, Channel or Packet workers enabled</td></tr>
<tr><td><code>wallet_balance</code></td><td>The balance of each wallet Hermes uses per chain</td><td><code>f64</code> ValueRecorder</td><td>None</td></tr>
<tr><td><code>tx_latency_submitted</code></td><td>Latency for all transactions submitted to a chain</td><td><code>u64</code> ValueRecorder</td><td>None</td></tr>
<tr><td><code>total_messages_submitted</code></td><td>Number of messages submitted to a specific chain</td><td><code>u64</code> Counter</td><td>None</td></tr>
</tbody></table>
</div>
<p>Notes &amp; more details below:</p>
<p><strong>What is a worker?</strong></p>
<ul>
<li>A worker is a separate thread of execution and there are five types of workers:
<ul>
<li><code>Client</code>: The worker that refreshed a client periodically and detects misbehaviour.</li>
<li><code>Connection</code>: The worker that handles connection open handshake that may be incomplete.</li>
<li><code>Channel</code>: The worker that handles channel open handshake that may be incomplete.</li>
<li><code>Packet</code>: The worker that handles packet relaying.</li>
<li><code>Wallet</code>: The worker that periodically queries for the balance of each wallet that Hermes is using and updates <code>wallet_balance</code> metric.</li>
</ul>
</li>
<li>For example, if your metrics show that you have 0 packet workers (<code>workers{type=&quot;packet&quot;} 0</code>), that is a clear indication that Hermes is <em>not relaying any packets at the moment</em>.</li>
</ul>
<p><strong>How do we define the latency of a submitted transaction?</strong>
The latency is defined as the difference between the moment when Hermes received an event (through the websocket) until the moment when the corresponding transaction(s) were submitted
into a full node's mempool.</p>
<ul>
<li>If a transaction is submitted it does not mean it was confirmed, see below for more details.</li>
<li>This metric is tracked per chain, counterparty chain, channel and port.</li>
</ul>
<p><strong>A note on wallet balances.</strong>
For the <code>wallet_balance</code>, we convert from a String into a f64, which can lead to a loss in precision in the displayed value.</p>
<h2 id="are-hermes-transactions-successful"><a class="header" href="#are-hermes-transactions-successful">Are Hermes transactions successful?</a></h2>
<p>This table shows the metrics for Hermes performance.
Importantly, these metrics are only displayed if the configuration <code>tx_confirmation = true</code> is set in your config.toml.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>tx_latency_confirmed</code></td><td>Latency for all transactions confirmed by a chain</td><td><code>u64</code> ValueRecorder</td><td>Transaction confirmation enabled</td></tr>
<tr><td><code>receive_packets_confirmed</code></td><td>Number of confirmed receive packets, per chain, channel and port</td><td><code>u64</code> Counter</td><td>Packet workers enabled and Transaction confirmation enabled</td></tr>
<tr><td><code>acknowledgment_packets_confirmed</code></td><td>Number of confirmed acknowledgment packets, per chain, channel and port</td><td><code>u64</code> Counter</td><td>Packet workers enabled and Transaction confirmation enabled</td></tr>
<tr><td><code>timeout_packets_confirmed</code></td><td>Number of confirmed timeout packets, per chain, channel and port</td><td><code>u64</code> Counter</td><td>Packet workers enabled and Transaction confirmation enabled</td></tr>
</tbody></table>
</div>
<p><strong>How do we define the latency of a confirmed transaction?</strong>
This is the difference between the moment when Hermes received an event until the corresponding transaction(s) were confirmed.</p>
<ul>
<li>Similarly to <code>tx_latency_submitted</code>, this metrics is tracked per chain, counterparty chain, channel and port.</li>
<li>This metrics usually contains strictly larger values than <code>tx_latency_submitted</code>, because Hermes first submits transactions into the network's mempool,
and then it takes some more time elapses until the network includes those transactions in a block.</li>
</ul>
<h2 id="what-is-the-overall-ibc-status-of-each-network"><a class="header" href="#what-is-the-overall-ibc-status-of-each-network">What is the overall IBC status of each network?</a></h2>
<p>These metrics are not specific to your Hermes instance. These are metrics that capture the activity of <em>all IBC relayers</em>.</p>
<blockquote>
<p>‼️ Important:
Your Hermes instance produces these metrics based on the <em>events</em> it receives via a websocket to the full nodes of each network.
If these events are not being updated, that is a good indication that either:</p>
<ul>
<li>The network has no IBC activity, or</li>
<li>The websocket connection to that network is broken.</li>
</ul>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>send_packet_events</code></td><td>Number of SendPacket events received</td><td><code>u64</code> Counter</td><td>Packet workers enabled</td></tr>
<tr><td><code>acknowledgement_events</code></td><td>Number of WriteAcknowledgement events received</td><td><code>u64</code> Counter</td><td>Packet workers enabled</td></tr>
<tr><td><code>timeout_events</code></td><td>Number of TimeoutPacket events received</td><td><code>u64</code> Counter</td><td>Packet workers enabled</td></tr>
<tr><td><code>ws_events</code></td><td>Number of events Hermes (including <code>send_packet</code>, <code>acknowledgment</code>, and <code>timeout</code>) received via the websocket subscription, per chain</td><td><code>u64</code> Counter</td><td>None</td></tr>
<tr><td><code>ws_reconnect</code></td><td>Number of times Hermes reconnected to the websocket endpoint, per chain</td><td><code>u64</code> Counter</td><td>None</td></tr>
<tr><td><code>queries</code></td><td>Number of queries submitted by Hermes, per chain and query type</td><td><code>u64</code> Counter      </td><td>None</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>Except for <code>ws_reconnect</code>, all these metrics should typically increase regularly in the common-case. That is an indication that the network is regularly producing new blocks and there is ongoing IBC activity, eg <code>send_packet</code>, <code>acknowledgment</code>, and <code>timeout</code>.</li>
<li>The metric <code>ws_reconnect</code> signals that the websocket connection was broken and Hermes had to re-establish that. It is usually an indication that your full node may be falling behind or is experiencing instability.</li>
</ul>
<p>Since Hermes v1, we also introduced 3 metrics that sketch the backlog status of IBC relaying.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>backlog_oldest_sequence</code></td><td>Sequence number of the oldest SendPacket event in the backlog</td><td><code>u64</code> ValueRecorder</td><td>Packet workers enabled</td></tr>
<tr><td><code>backlog_oldest_timestamp</code></td><td>Local timestamp for the oldest SendPacket event in the backlog</td><td><code>u64</code> ValueRecorder </td><td>Packet workers enabled</td></tr>
<tr><td><code>backlog_size</code></td><td>Total number of SendPacket events in the backlog</td><td><code>u64</code> ValueRecorder </td><td>Packet workers enabled</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>The <code>backlog_size</code> defines how many IBC packets users sent and were not yet relayed (i.e., received on the destination network, or timed-out).
If this metric is increasing, it signals that the packet queue is increasing and there may be some errors in the Hermes logs that need your attention.</li>
<li>If the <code>backlog_oldest_sequence</code> remains unchanged for more than a few minutes, that means that the packet with the respective sequence number is likely blocked
and cannot be relayed. To understand for how long the packet is block, Hermes will populate <code>backlog_oldest_timestamp</code>  with the local time when it first observed
the <code>backlog_oldest_sequence</code> that is blocked.</li>
</ul>
<h2 id="how-efficient-and-how-secure-is-the-ibc-status-on-each-network"><a class="header" href="#how-efficient-and-how-secure-is-the-ibc-status-on-each-network">How efficient and how secure is the IBC status on each network?</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>queries</code></td><td>Number of queries submitted by Hermes, per chain and query type                                                                                                             </td><td><code>u64</code> Counter       </td><td>None</td></tr>
<tr><td> <code>queries_cache_hits</code></td><td>Number of cache hits for queries submitted by Hermes, per chain and query type                                                                                           </td><td><code>u64</code> Counter       </td><td>None</td></tr>
<tr><td><code>tx_latency_submitted</code></td><td>Latency for all transactions submitted to a chain (i.e., difference between the moment when Hermes received an event until the corresponding transaction(s) were submitted), per chain, counterparty chain, channel and port</td><td><code>u64</code> ValueRecorder</td><td>None</td></tr>
<tr><td> <code>cleared_send_packet_count</code> </td><td>Number of SendPacket events received during the initial and periodic clearing, per chain, counterparty chain, channel and port</td><td><code>u64</code> Counter</td><td>Packet workers enabled, and periodic packet clearing or clear on start enabled</td></tr>
<tr><td> <code>cleared_acknowledgment_count</code></td><td>Number of WriteAcknowledgement events received during the initial and periodic clearing, per chain, counterparty chain, channel and port</td><td><code>u64</code> Counter</td><td>Packet workers enabled, and periodic packet clearing or clear on start enabled</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>The two metrics <code>cleared_send_packet_count</code> and <code>cleared_acknowledgment_count</code> are only populated if <code>tx_confirmation = true</code>.
These two metrics usually correlate with <code>backlog_*</code> metrics. They are an indication that IBC packet relaying may be unsuccessful and that Hermes periodically
finds packets to clear (i.e., unblock).</li>
<li><code>queries</code> and <code>queries_cache_hits</code> values are complementary. For the total number of queries, the two metrics should be summed for a specific query type.</li>
</ul>
<p>For security, we only expose one metric, described in the table below.
Note that this metrics is disabled if <code>misbehaviour = false</code> in your Hermes config.toml.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th><th>Configuration Dependencies</th></tr></thead><tbody>
<tr><td><code>client_misbehaviours_submitted</code></td><td>Number of misbehaviours detected and submitted, per sending chain, receiving chain and client</td><td><code>u64</code> Counter</td><td>Client workers enabled and Clients misbehaviour detection enabled</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="integration-with-prometheus"><a class="header" href="#integration-with-prometheus">Integration with Prometheus</a></h1>
<p>With the <code>enabled = true</code> setting for <code>telemetry</code> in your config.toml, the telemetry service will be enabled and will serve the metrics using
the Prometheus encoder over HTTP at <a href="http://localhost:3001/metrics"><code>http://localhost:3001/metrics</code></a>.</p>
<p>After starting Hermes with <code>hermes start</code>, and letting it run for a while to relay packets,
open <a href="http://localhost:3001/metrics"><code>http://localhost:3001/metrics</code></a> in a browser, you should
see Prometheus-encoded metrics.</p>
<p>For example, with two channels and after transferring some tokens between the chains:</p>
<pre><code class="language-text"># HELP acknowledgement_events Number of WriteAcknowledgement events received
# TYPE acknowledgement_events counter
acknowledgement_events{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;} 2
acknowledgement_events{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;} 2
# HELP acknowledgment_packets_confirmed Number of confirmed acknowledgment packets. Available if relayer runs with Tx confirmation enabled
# TYPE acknowledgment_packets_confirmed counter
acknowledgment_packets_confirmed{src_chain=&quot;ibc-0&quot;,src_channel=&quot;channel-0&quot;,src_port=&quot;transfer&quot;} 2
acknowledgment_packets_confirmed{src_chain=&quot;ibc-1&quot;,src_channel=&quot;channel-0&quot;,src_port=&quot;transfer&quot;} 2
# HELP backlog_oldest_sequence Sequence number of the oldest SendPacket event in the backlog
# TYPE backlog_oldest_sequence gauge
backlog_oldest_sequence{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;} 0
backlog_oldest_sequence{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;} 0
# HELP backlog_oldest_timestamp Local timestamp for the oldest SendPacket event in the backlog
# TYPE backlog_oldest_timestamp gauge
backlog_oldest_timestamp{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;} 0
backlog_oldest_timestamp{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;} 0
# HELP backlog_size Total number of SendPacket events in the backlog
# TYPE backlog_size gauge
backlog_size{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;} 0
backlog_size{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;} 0
# HELP client_updates_submitted Number of client update messages submitted
# TYPE client_updates_submitted counter
client_updates_submitted{chain=&quot;ibc-0&quot;,client=&quot;07-tendermint-0&quot;} 8
client_updates_submitted{chain=&quot;ibc-1&quot;,client=&quot;07-tendermint-0&quot;} 19
# HELP queries Number of queries submitted by Hermes
# TYPE queries counter
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_application_status&quot;} 486
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_channel&quot;} 20
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_client_state&quot;} 375
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_clients&quot;} 1
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_commitment_prefix&quot;} 2
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_connection&quot;} 21
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_consensus_state&quot;} 373
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_consensus_states&quot;} 2
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_latest_height&quot;} 1
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_packet_acknowledgements&quot;} 2
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_packet_commitments&quot;} 3
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_staking_params&quot;} 2
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_txs&quot;} 48
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_unreceived_acknowledgements&quot;} 4
queries{chain=&quot;ibc-0&quot;,query_type=&quot;query_unreceived_packets&quot;} 5
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_application_status&quot;} 449
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_blocks&quot;} 1
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_channel&quot;} 21
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_client_connections&quot;} 3
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_client_state&quot;} 367
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_clients&quot;} 1
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_commitment_prefix&quot;} 2
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_connection&quot;} 22
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_connection_channels&quot;} 5
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_connections&quot;} 6
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_consensus_state&quot;} 372
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_consensus_states&quot;} 2
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_latest_height&quot;} 1
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_packet_acknowledgements&quot;} 1
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_packet_commitments&quot;} 3
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_staking_params&quot;} 2
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_txs&quot;} 40
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_unreceived_acknowledgements&quot;} 5
queries{chain=&quot;ibc-1&quot;,query_type=&quot;query_unreceived_packets&quot;} 4
# HELP queries_cache_hits Number of cache hits for queries submitted by Hermes
# TYPE queries_cache_hits counter
queries_cache_hits{chain=&quot;ibc-0&quot;,query_type=&quot;query_channel&quot;} 13
queries_cache_hits{chain=&quot;ibc-0&quot;,query_type=&quot;query_client_state&quot;} 29
queries_cache_hits{chain=&quot;ibc-0&quot;,query_type=&quot;query_connection&quot;} 29
queries_cache_hits{chain=&quot;ibc-0&quot;,query_type=&quot;query_latest_height&quot;} 133
queries_cache_hits{chain=&quot;ibc-1&quot;,query_type=&quot;query_channel&quot;} 6
queries_cache_hits{chain=&quot;ibc-1&quot;,query_type=&quot;query_client_state&quot;} 50
queries_cache_hits{chain=&quot;ibc-1&quot;,query_type=&quot;query_connection&quot;} 17
queries_cache_hits{chain=&quot;ibc-1&quot;,query_type=&quot;query_latest_height&quot;} 64
# HELP receive_packets_confirmed Number of confirmed receive packets. Available if relayer runs with Tx confirmation enabled
# TYPE receive_packets_confirmed counter
receive_packets_confirmed{src_chain=&quot;ibc-0&quot;,src_channel=&quot;channel-0&quot;,src_port=&quot;transfer&quot;} 2
receive_packets_confirmed{src_chain=&quot;ibc-1&quot;,src_channel=&quot;channel-0&quot;,src_port=&quot;transfer&quot;} 2
# HELP send_packet_events Number of SendPacket events received
# TYPE send_packet_events counter
send_packet_events{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;} 2
send_packet_events{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;} 2
# HELP total_messages_submitted Number of messages submitted to a specific chain
# TYPE total_messages_submitted counter
total_messages_submitted{chain=&quot;ibc-0&quot;} 11
total_messages_submitted{chain=&quot;ibc-1&quot;} 22
# HELP tx_latency_confirmed The latency for all transactions submitted &amp; confirmed to a specific chain, i.e. the difference between the moment when Hermes received a batch of events until the corresponding transaction(s) were confirmed. Milliseconds.
# TYPE tx_latency_confirmed histogram
tx_latency_confirmed_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;1000&quot;} 0
tx_latency_confirmed_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;5000&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;9000&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;13000&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;17000&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;20000&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;+Inf&quot;} 4
tx_latency_confirmed_sum{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;} 14265
tx_latency_confirmed_count{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;1000&quot;} 0
tx_latency_confirmed_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;5000&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;9000&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;13000&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;17000&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;20000&quot;} 4
tx_latency_confirmed_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;+Inf&quot;} 4
tx_latency_confirmed_sum{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;} 10103
tx_latency_confirmed_count{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;} 4
# HELP tx_latency_submitted The latency for all transactions submitted to a specific chain, i.e. the difference between the moment when Hermes received a batch of events and when it submitted the corresponding transaction(s). Milliseconds.
# TYPE tx_latency_submitted histogram
tx_latency_submitted_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;200&quot;} 0
tx_latency_submitted_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;500&quot;} 2
tx_latency_submitted_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;1000&quot;} 4
tx_latency_submitted_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;2000&quot;} 4
tx_latency_submitted_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;5000&quot;} 4
tx_latency_submitted_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;10000&quot;} 4
tx_latency_submitted_bucket{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;,le=&quot;+Inf&quot;} 4
tx_latency_submitted_sum{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;} 1941
tx_latency_submitted_count{chain=&quot;ibc-0&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-1&quot;,port=&quot;transfer&quot;} 4
tx_latency_submitted_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;200&quot;} 0
tx_latency_submitted_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;500&quot;} 0
tx_latency_submitted_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;1000&quot;} 4
tx_latency_submitted_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;2000&quot;} 4
tx_latency_submitted_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;5000&quot;} 4
tx_latency_submitted_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;10000&quot;} 4
tx_latency_submitted_bucket{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;,le=&quot;+Inf&quot;} 4
tx_latency_submitted_sum{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;} 2535
tx_latency_submitted_count{chain=&quot;ibc-1&quot;,channel=&quot;channel-0&quot;,counterparty=&quot;ibc-0&quot;,port=&quot;transfer&quot;} 4
# HELP wallet_balance The balance of each wallet Hermes uses per chain. Please note that when converting the balance to f64 a loss in precision might be introduced in the displayed value
# TYPE wallet_balance gauge
wallet_balance{account=&quot;cosmos1a450s556xf9n63vdd9aet6g6t29tm207ygp5rj&quot;,chain=&quot;ibc-1&quot;,denom=&quot;stake&quot;} 99969960
wallet_balance{account=&quot;cosmos1fafdyl4hl0ltcx4c3y9zhnkf5uxcah9tefuavy&quot;,chain=&quot;ibc-0&quot;,denom=&quot;stake&quot;} 99983143
# HELP workers Number of workers
# TYPE workers gauge
workers{type=&quot;channel&quot;} 3
workers{type=&quot;client&quot;} 2
workers{type=&quot;connection&quot;} 3
workers{type=&quot;packet&quot;} 2
workers{type=&quot;wallet&quot;} 2
# HELP ws_events How many IBC events did Hermes receive via the websocket subscription
# TYPE ws_events counter
ws_events{chain=&quot;ibc-0&quot;} 115
ws_events{chain=&quot;ibc-1&quot;} 128
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-api"><a class="header" href="#rest-api">REST API</a></h1>
<p><em>Since version 0.7.0.</em></p>
<p>Hermes features a built-in HTTP server which exposes information
about the relayer configuration and state via a REST API.</p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="rest-api.html#configuration">Configuration</a></li>
<li><a href="rest-api.html#endpoints">Endpoints</a>
<ul>
<li><a href="rest-api.html#get-version">GET <code>/version</code></a></li>
<li><a href="rest-api.html#get-chains">GET <code>/chains</code></a></li>
<li><a href="rest-api.html#get-chainid">GET <code>/chain/:id</code></a></li>
<li><a href="rest-api.html#get-state">GET <code>/state</code></a></li>
</ul>
</li>
</ul>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<p>The REST API is not active by default, and must be enabled in the relayer configuration:</p>
<pre><code class="language-toml">[rest]
enabled = true
host    = '127.0.0.1'
port    = 3000
</code></pre>
<p>Please see the <a href="./config.html#rest">relevant section in the <em>Configuration</em> page</a> for details about the configuration options.</p>
<h2 id="endpoints"><a class="header" href="#endpoints">Endpoints</a></h2>
<h3 id="get-version"><a class="header" href="#get-version">GET <code>/version</code></a></h3>
<p>This endpoint returns the version of the Hermes (under the <code>ibc-relayer</code> key) as well
as the version of the REST server itself (under the <code>ibc-relayer-rest</code> key).</p>
<p><strong>Example</strong></p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/version' | jq
</code></pre>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;ibc-relayer&quot;,
    &quot;version&quot;: &quot;v1.0.0&quot;
  },
  {
    &quot;name&quot;: &quot;ibc-relayer-rest&quot;,
    &quot;version&quot;: &quot;0.1.0&quot;
  }
]
</code></pre>
<h3 id="get-chains"><a class="header" href="#get-chains">GET <code>/chains</code></a></h3>
<p>This endpoint return the identifiers of the chains that Hermes is connected to.
Those identifiers can be used with the <code>/chain/:id</code> endpoint to gather more
information about each chain's configuration. See the next section for more details.</p>
<p><strong>Example</strong></p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/chains' | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    &quot;ibc-0&quot;,
    &quot;ibc-1&quot;
  ]
}
</code></pre>
<h3 id="get-chainid"><a class="header" href="#get-chainid">GET <code>/chain/:id</code></a></h3>
<p>This endpoint returns the configuration of the chain with the given identifier,
where <code>:id</code> stands for the identififer.</p>
<p><strong>Example</strong></p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/chain/ibc-0' | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;id&quot;: &quot;ibc-0&quot;,
    &quot;rpc_addr&quot;: &quot;http://127.0.0.1:26657/&quot;,
    &quot;websocket_addr&quot;: &quot;ws://127.0.0.1:26657/websocket&quot;,
    &quot;grpc_addr&quot;: &quot;http://127.0.0.1:9090/&quot;,
    &quot;rpc_timeout&quot;: &quot;10s&quot;,
    &quot;account_prefix&quot;: &quot;cosmos&quot;,
    &quot;key_name&quot;: &quot;testkey&quot;,
    &quot;store_prefix&quot;: &quot;ibc&quot;,
    &quot;max_gas&quot;: 900000000,
    &quot;gas_multiplier&quot;: 1.0,
    &quot;max_msg_num&quot;: 60,
    &quot;max_tx_size&quot;: 2097152,
    &quot;clock_drift&quot;: &quot;5s&quot;,
    &quot;trusting_period&quot;: &quot;14days&quot;,
    &quot;trust_threshold&quot;: {
      &quot;numerator&quot;: &quot;1&quot;,
      &quot;denominator&quot;: &quot;3&quot;
    },
    &quot;gas_price&quot;: {
      &quot;price&quot;: 0.001,
      &quot;denom&quot;: &quot;stake&quot;
    },
    &quot;packet_filter&quot;: {
      &quot;policy&quot;: &quot;allowall&quot;
    }
  }
}
</code></pre>
<h3 id="get-state"><a class="header" href="#get-state">GET <code>/state</code></a></h3>
<p>This endpoint returns the current state of the relayer,
namely which chains it is connected to, as well as a description
of all the workers which are currently active.</p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/state' | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;chains&quot;: [
      &quot;ibc-0&quot;,
      &quot;ibc-1&quot;
    ],
    &quot;workers&quot;: {
      &quot;Client&quot;: [
        {
          &quot;id&quot;: 3,
          &quot;object&quot;: {
            &quot;type&quot;: &quot;Client&quot;,
            &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
            &quot;dst_client_id&quot;: &quot;07-tendermint-0&quot;,
            &quot;src_chain_id&quot;: &quot;ibc-0&quot;
          }
        },
        {
          &quot;id&quot;: 4,
          &quot;object&quot;: {
            &quot;type&quot;: &quot;Client&quot;,
            &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
            &quot;dst_client_id&quot;: &quot;07-tendermint-1&quot;,
            &quot;src_chain_id&quot;: &quot;ibc-0&quot;
          }
        },
        {
          &quot;id&quot;: 1,
          &quot;object&quot;: {
            &quot;type&quot;: &quot;Client&quot;,
            &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
            &quot;dst_client_id&quot;: &quot;07-tendermint-0&quot;,
            &quot;src_chain_id&quot;: &quot;ibc-1&quot;
          }
        },
        {
          &quot;id&quot;: 2,
          &quot;object&quot;: {
            &quot;type&quot;: &quot;Client&quot;,
            &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
            &quot;dst_client_id&quot;: &quot;07-tendermint-1&quot;,
            &quot;src_chain_id&quot;: &quot;ibc-1&quot;
          }
        }
      ]
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>This section includes tutorials for some common relayer use cases and commands. You can also refer to the <a href="tutorials/../commands/index.html">Commands Reference</a> section to learn more about individual commands.</p>
<h2 id="basic-tutorials"><a class="header" href="#basic-tutorials">Basic tutorials</a></h2>
<p><strong><a href="tutorials/./local-chains/index.html">Two Local Chains</a></strong></p>
<p>In this tutorial you will learn how to start two local <a href="https://github.com/cosmos/gaia"><code>Cosmos Gaia</code></a> chains that support the <code>IBC</code> protocol and start relaying packets between them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-relayer-with-two-local-chains"><a class="header" href="#tutorial-relayer-with-two-local-chains">Tutorial: Relayer with two local chains</a></h1>
<p>In this tutorial we will show how you can test the relayer against two chains using Gaiad manager <code>gm</code>. This is the easiest way to get started.</p>
<p>Using <code>gm</code> we will start two <a href="https://github.com/cosmos/gaia"><code>gaia</code></a> chains that support the <code>IBC</code> protocol.</p>
<p>Follow the steps in this tutorial section starting with the <a href="tutorials/local-chains/./gaia.html">Install Gaia</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-gaia"><a class="header" href="#install-gaia">Install Gaia</a></h1>
<p>For <code>gm</code> to start the chains, it requires gaia to be installed.</p>
<blockquote>
<p><strong>NOTE</strong>: This assumes you have <code>Golang</code> programming language installed on 
your machine. If not, please ensure you install before proceeding. See 
more details in the <a href="tutorials/local-chains/../../pre_requisites.html#2-golang">Pre-requisites</a> section.</p>
</blockquote>
<h4 id="clone-gaia"><a class="header" href="#clone-gaia">Clone gaia</a></h4>
<p>Clone the repository from Github:</p>
<pre><code class="language-shell">git clone https://github.com/cosmos/gaia.git ~/go/src/github.com/cosmos/gaia
</code></pre>
<h4 id="build-and-install"><a class="header" href="#build-and-install">Build and Install</a></h4>
<p>Run the <code>make</code> command to build and install <code>gaiad</code></p>
<pre><code class="language-shell">cd ~/go/src/github.com/cosmos/gaia
git checkout &lt;latest-release-tag&gt; 
make install
</code></pre>
<blockquote>
<p>Find the <a href="https://github.com/cosmos/gaia/releases">latest-release-tag</a> here.</p>
</blockquote>
<blockquote>
<p><strong>NOTE</strong>: Specific to M1 MacOS, there could be some warnings after running <code>make install</code> which can be safely ignored as long as <code>gaiad</code> binaries are built in <code>$HOME/go/bin</code> directory.
<br /><br />Add the path <code>export PATH=$HOME/go/bin:$PATH</code></p>
</blockquote>
<p>If the command above is successful you can run the following command to ensure it was properly installed:</p>
<pre><code class="language-shell">gaiad version --log_level error --long | head -n4
</code></pre>
<p>Output:</p>
<pre><code class="language-shell">name: gaia
server_name: gaiad
version: v4.2.1
commit: dbd8a6fb522c571debf958837f9113c56d418f6b
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>In the next section you will learn how to <a href="tutorials/local-chains/./start.html">start two local chains</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="install-gaiad-manager"><a class="header" href="#install-gaiad-manager">Install Gaiad Manager</a></h2>
<p>Gaiad manager (<code>gm</code>) is a command-line tool (CLI) that helps manage local <code>gaiad</code> networks. </p>
<p>Follow the instructions </p>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<ul>
<li>Bourne shell (<code>sh</code>)</li>
<li><a href="https://github.com/freshautomations/sconfig/releases"><code>sconfig</code></a> and
<a href="https://github.com/freshautomations/stoml/releases"><code>stoml</code></a> installed in your PATH (put them in <code>/usr/local/bin</code>)</li>
<li><code>sed</code>, <code>tr</code></li>
<li>For shell-completion Bourne Again Shell (<code>bash</code>) for the local user</li>
</ul>
<h3 id="how-to-run"><a class="header" href="#how-to-run">How to run</a></h3>
<ol>
<li>Install the dependencies.</li>
</ol>
<p>On MacOS:</p>
<pre><code class="language-bash"># You might need sudo permissions and create the `usr/local/bin` directory

curl -Lo /usr/local/bin/sconfig https://github.com/freshautomations/sconfig/releases/download/v0.1.0/sconfig_darwin_amd64
curl -Lo /usr/local/bin/stoml https://github.com/freshautomations/stoml/releases/download/v0.7.0/stoml_darwin_amd64
chmod 755 /usr/local/bin/sconfig
chmod 755 /usr/local/bin/stoml
</code></pre>
<p>On Linux:</p>
<pre><code class="language-bash">curl -Lo /usr/local/bin/sconfig https://github.com/freshautomations/sconfig/releases/download/v0.1.0/sconfig_linux_amd64
curl -Lo /usr/local/bin/stoml https://github.com/freshautomations/stoml/releases/download/v0.7.0/stoml_linux_amd64
chmod 755 /usr/local/bin/sconfig
chmod 755 /usr/local/bin/stoml
</code></pre>
<ol start="2">
<li>Install <code>gm</code></li>
</ol>
<pre><code class="language-bash">git clone https://github.com/informal/ibc-rs
ibc-rs/scripts/gm/bin/gm install
</code></pre>
<p>Alternatively, you can create the folder <code>$HOME/.gm/bin</code> and copy the files from <code>scripts/gm/bin</code> in there.</p>
<ol start="3">
<li>Activate <code>gm</code></li>
</ol>
<ul>
<li>Add <code>source $HOME/.gm/bin/shell-support</code> to a file that executes when a new terminal window comes up
(<code>$HOME/.bash_profile</code> or <code>$HOME/.bashrc</code> or <code>$HOME/.zprofile</code>)</li>
<li>(Optional) Enable auto-completion
On MacOS:</li>
</ul>
<pre><code class="language-bash"># Note: zsh is the default shell on MacOS, so no need to run this unless you explicitly use bash
brew install bash-completion
</code></pre>
<p>On Linux:</p>
<pre><code>apt install bash-completion || yum install bash-completion
</code></pre>
<ul>
<li>Restart your terminal</li>
</ul>
<p>Note: The <code>shell-support</code> script allows bash-completion as well as creating a <code>gm</code> alias, so you don't need to add more
entries to your PATH environment variable. If you don't want to use this, you can always just add <code>$HOME/.gm/bin</code> to
your path.</p>
<h3 id="the-configuration-gmtoml"><a class="header" href="#the-configuration-gmtoml">The configuration: <code>gm.toml</code></a></h3>
<p><strong>Where</strong>: <code>$HOME/.gm/gm.toml</code>.</p>
<p><strong>Description</strong>: This file contains all the high-level node configuration that <code>gm</code> is aware of. Note that all entries under <code>[global]</code> are also valid entries under any <code>[node]</code> header, and can be used to override the global entries for specific nodes/validators.</p>
<p><strong>Entries</strong>: All entries are defined and documented in the <code>scripts/gm/gm.toml</code> example configuration file.</p>
<p>Copy and paste below to <code>$HOME/.gm/gm.toml</code></p>
<p>The following configuration you need to specify 2 <code>gaiad</code> chains. <code>hermes</code> will know about these chains.</p>
<pre><code class="language-toml">[global]
  add_to_hermes = false
  auto_maintain_config = true
  extra_wallets = 2
  gaiad_binary = &quot;~/go/bin/gaiad&quot;
  hdpath = &quot;&quot;
  home_dir = &quot;$HOME/.gm&quot;
  ports_start_at = 27000
  validator_mnemonic = &quot;&quot;
  wallet_mnemonic = &quot;&quot;

  [global.hermes]
    binary = &quot;./hermes&quot; #change this path according to your setup
    config = &quot;$HOME/.hermes/config.toml&quot;
    log_level = &quot;info&quot;
    telemetry_enabled = true
    telemetry_host = &quot;127.0.0.1&quot;
    telemetry_port = 3001

[ibc-0]
  ports_start_at = 27010

[ibc-1]
  ports_start_at = 27020

[node-0]
  add_to_hermes = true
  network = &quot;ibc-0&quot;
  ports_start_at = 27030

[node-1]
  add_to_hermes = true
  network = &quot;ibc-1&quot;
  ports_start_at = 27040

</code></pre>
<p>In the <a href="tutorials/local-chains/start.html">next section</a> we will configure hermes and start local chains using <code>gm</code></p>
<blockquote>
<p><strong>NOTE:</strong> Go to this page for more detils about <a href="https://github.com/informalsystems/ibc-rs/tree/master/scripts/gm">Gaiad Manager</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="start-the-local-chains"><a class="header" href="#start-the-local-chains">Start the local chains</a></h1>
<p>In this chapter, you will learn how to spawn two Gaia chains, and use Hermes to relay packets between them.</p>
<p>To spawn the chains and configure Hermes accordingly, we will make use of Gaiad Manager <code>gm</code> that we installed in the last section <a href="tutorials/local-chains/gaiad-manager.html">Install Gaiad Manager</a></p>
<h3 id="stop-existing-gaiad-processes"><a class="header" href="#stop-existing-gaiad-processes">Stop existing <code>gaiad</code> processes</a></h3>
<p>If this is not the first time you are running the script, you can manually stop the two gaia instances executing the following command to kill all <code>gaiad</code> processes:</p>
<pre><code class="language-shell">killall gaiad
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If you have any <code>Docker</code> containers running that might be using the same ports as <code>gaiad</code> (e.g. port 26657 or port 9090), please ensure you stop them first before proceeding to the next step.</p>
</blockquote>
<h3 id="configuration-file"><a class="header" href="#configuration-file">Configuration file</a></h3>
<p>Gaiad Manager <code>gm</code> takes care of creating the configuration file. Run the command below to create the <code>$HOME/.hermes/config.toml</code> file</p>
<pre><code class="language-bash">gm hermes config
</code></pre>
<p>Please check the <a href="tutorials/local-chains/../../config.html"><code>Configuration</code></a> section for more information about the relayer configuration file.</p>
<p>Based on the <code>gm.toml</code> we created in the previous section <a href="tutorials/local-chains/gaiad-manager.html">Install Gaiad Manager</a>, your <code>$HOME/.hermes/config.toml</code> file should look like below :</p>
<p><strong>config.toml</strong></p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = true

[mode.channels]
enabled = true

[mode.packets]
enabled = true
clear_interval = 100
clear_on_start = true
tx_confirmation = true

[telemetry]
enabled = true
host = '127.0.0.1'
port = 3001

[[chains]]
id = 'ibc-0'
rpc_addr = 'http://localhost:27030'
grpc_addr = 'http://localhost:27032'
websocket_addr = 'ws://localhost:27030/websocket'
rpc_timeout = '15s'
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.01, denom = 'stake' }
max_gas = 10000000
clock_drift = '5s'
trusting_period = '14days'
trust_threshold = { numerator = '1', denominator = '3' }

[[chains]]
id = 'ibc-1'
rpc_addr = 'http://localhost:27040'
grpc_addr = 'http://localhost:27042'
websocket_addr = 'ws://localhost:27040/websocket'
rpc_timeout = '15s'
account_prefix = 'cosmos'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.01, denom = 'stake' }
max_gas = 10000000
clock_drift = '5s'
trusting_period = '14days'
trust_threshold = { numerator = '1', denominator = '3' }
</code></pre>
<h3 id="adding-private-keys-to-the-chains"><a class="header" href="#adding-private-keys-to-the-chains">Adding private keys to the chains</a></h3>
<p><code>gm</code> will automatically generate private keys that will be used by <code>hermes</code> to sign transactions.</p>
<p>To see the keys generated by <code>gm</code>, run the command below</p>
<pre><code class="language-bash">gm key
</code></pre>
<p>This will generate an output similar to the one below (albeit all on the same line):</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;testkey&quot;,
  &quot;type&quot;: &quot;local&quot;,
  &quot;address&quot;: &quot;cosmos1tc3vcuxyyac0dmayf887t95tdg7qpyql48w7gj&quot;,
  &quot;pubkey&quot;: &quot;cosmospub1addwnpepqgg7ng4ycm60pdxfzdfh4hjvkwcr3da59mr8k883vsstx60ruv7kur4525u&quot;,
  &quot;mnemonic&quot;: &quot;[24 words mnemonic]&quot;
}
</code></pre>
<p>Next, we will need to associate a private key with chains <code>ibc-0</code> and <code>ibc-1</code> which <code>hermes</code> will use to sign transactions. </p>
<pre><code class="language-bash">gm hermes keys
</code></pre>
<p>If successful, the command should show an output similar to:</p>
<pre><code>Success: Added key testkey ([ADDRESS]) on [CHAIN ID] chain
</code></pre>
<h3 id="starting-the-chains-with-gm"><a class="header" href="#starting-the-chains-with-gm">Starting the chains with <code>gm</code></a></h3>
<p>Make sure you have the <code>$HOME/.gm/gm.toml</code> that we configured in the previous section <a href="tutorials/local-chains/gaiad-manager.html">Install Gaiad Manager</a> and run the <code>gm</code> command below to start the chains.</p>
<pre><code class="language-bash">gm start
</code></pre>
<p>This configures and starts two <strong><code>gaiad</code></strong> instances, one named <strong><code>ibc-0</code></strong> and the other <strong><code>ibc-1</code></strong></p>
<pre class="mermaid">graph TD
    A[gm] --&gt;|start| C(start chains)
    C --&gt;|gaiad| D[ibc-0]
    C --&gt;|gaiad| F[ibc-1]
</pre>
<p>If the command runs successfully you should see a message similar to the one below in the terminal:</p>
<pre><code class="language-shell">network1 started, PID: 99468, LOG: /Users/testuser/.gm/network1/log
network2 started, PID: 99538, LOG: /Users/testuser/.gm/network2/log
ibc-0 started, PID: 99645, LOG: /Users/testuser/.gm/ibc-0/log
ibc-1 started, PID: 99750, LOG: /Users/testuser/.gm/ibc-1/log
</code></pre>
<p>Run the below command to check the status of the chains</p>
<pre><code class="language-bash">gm status
</code></pre>
<h3 id="homegm-directory"><a class="header" href="#homegm-directory">$HOME/.gm directory</a></h3>
<p>This directory is creted when you install <code>gm</code> and the binaries are stored here but when we start the chains, all the related files and folders are stored here as well.</p>
<p>The $HOME/.gm directory has a tree structure similar to the one below:</p>
<pre><code class="language-shell">.gm
├── bin
│   ├── gm
│   ├── lib-gm
│   └── shell-support
├── gm.toml
├── ibc-0
│   ├── config
│   ├── data
│   ├── init.json
│   ├── keyring-test
│   ├── log
│   ├── pid
│   ├── validator_seed.json
│   ├── wallet1_seed.json
│   ├── wallet2_seed.json
│   └── wallet_seed.json
├── ibc-1
│   ├── config
│   ├── data
│   ├── init.json
│   ├── keyring-test
│   ├── log
│   ├── pid
│   ├── validator_seed.json
│   ├── wallet1_seed.json
│   ├── wallet2_seed.json
│   └── wallet_seed.json
├── node-0
│   ├── config
│   ├── data
│   ├── init.json
│   ├── keyring-test
│   ├── log
│   └── pid
└── node-1
    ├── config
    ├── data
    ├── init.json
    ├── keyring-test
    ├── log
    └── pid

</code></pre>
<blockquote>
<p><strong>Tip</strong>: You can use the command <code>tree ./data/ -L 2</code> to view the folder structure above</p>
</blockquote>
<h3 id="homehermes-directory"><a class="header" href="#homehermes-directory">$HOME/.hermes directory</a></h3>
<p>By the default <code>hermes</code> expects the configuration file to be in the <strong><code>$HOME/.hermes</code></strong> folder.</p>
<p>It also stores the private keys for each chain in this folder as outlined in the <a href="tutorials/local-chains/../../commands/keys/index.html">Keys</a> section.</p>
<p>After executing <code>gm start</code>, this is how the folder should look like:</p>
<pre><code class="language-shell">$HOME/.hermes/
├── config.toml
└── keys
    ├── ibc-0
    │   └── keyring-test
    │       └── testkey.json
    └── ibc-1
        └── keyring-test
            └── testkey.json
</code></pre>
<h4 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h4>
<p><a href="tutorials/local-chains/./identifiers.html">The next section</a> describes how identifers for clients, connections and channels
are allocated, and will walk you through how to pre-allocate some identifers
to help matching them with their corresponding chains for the purpose of this tutorial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>A chain allocates identifiers when it creates clients, connections and channels. These identifiers can subsequently be used to refer to existing clients, connections and channels.</p>
<blockquote>
<p>NOTE: If you want to ensure you get the same identifiers while following the tutorials, run the each of the three commands below <strong>once</strong> on <code>ibc-1</code>. This will ensure that when going through the tutorial, a second channel on <code>ibc-1</code> with identifier <code>channel-1</code> will created.</p>
</blockquote>
<p>Chains allocate identifiers using a chain specific allocation scheme. Currently, <em>cosmos-sdk</em> implementation uses the follow identifiers:</p>
<h3 id="1-client-identifiers"><a class="header" href="#1-client-identifiers">1. Client Identifiers</a></h3>
<p><strong><code>07-tendermint-&lt;n&gt;</code></strong> for tendermint clients</p>
<p>For example <code>07-tendermint-0</code> is assigned to the first client created on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes create client --host-chain ibc-1 --reference-chain ibc-0
</code></pre>
<pre><code class="language-json">Success: CreateClient(
   CreateClient(
       Attributes {
           height: Height {
               revision: 1,
               height: 103,
           },
           client_id: ClientId(
               &quot;07-tendermint-0&quot;,
           ),
           client_type: Tendermint,
           consensus_height: Height {
               revision: 0,
               height: 112,
           },
       },
   ),
)
</code></pre>
<p>We will create a second client on <code>ibc-1</code> with identifier <code>07-tendermint-1</code> in the client tutorial.</p>
<h3 id="2-connection-identifiers"><a class="header" href="#2-connection-identifiers">2. Connection Identifiers</a></h3>
<p><strong><code>connection-&lt;n&gt;</code></strong> for connections</p>
<p>For example <code>connection-0</code> is assigned to the first connection created on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx conn-init --b-chain ibc-1 --a-chain ibc-0 --b-client 07-tendermint-0 --a-client 07-tendermint-0
</code></pre>
<pre><code class="language-json">Success: OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height {
                revision: 1,
                height: 119,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)
</code></pre>
<p>We will create a second connection on <code>ibc-1</code> with identifier <code>connection-1</code> in the connection tutorial.</p>
<h3 id="3-channel-identifiers"><a class="header" href="#3-channel-identifiers">3. Channel Identifiers</a></h3>
<p><code>channel-&lt;n&gt;</code> for channels</p>
<p>For example <code>channel-0</code> is assigned to the first channel created on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx chan-open-init --b-chain ibc-1 --a-chain ibc-0 --b-connection connection-0 --b-port transfer --a-port transfer
</code></pre>
<pre><code class="language-json">Success: OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height {
                revision: 1,
                height: 225,
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: None,
        },
    ),
)
</code></pre>
<p>In the following tutorials the <strong><code>ibc-0</code></strong> and <strong><code>ibc-1</code></strong> chains are setup and configured. </p>
<p>For clarity, the tutorials run on a setup where the identifiers allocated to the client, connection and channel on <strong><code>ibc-0</code></strong> are <strong><code>07-tendermint-0</code></strong>, <strong><code>connection-0</code></strong> and <strong><code>channel-0</code></strong> respectively. Identifiers allocated to the client, connection and channel on <strong><code>ibc-1</code></strong> are <strong><code>07-tendermint-1</code></strong>, <strong><code>connection-1</code></strong> and <strong><code>channel-1</code></strong> respectively.</p>
<p>Before going over the next sections, please ensure the commands above are executed.</p>
<h3 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h3>
<p>The following sections describe the commands to connect and relay packets between two chains.
You can also use a <a href="tutorials/local-chains/./relay-paths/index.html">simplified approach</a> for managing relaying paths.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect-the-chains-using-relay-paths"><a class="header" href="#connect-the-chains-using-relay-paths">Connect the chains using relay paths</a></h1>
<p>A relay path refers to a specific channel used to interconnect two chains and over which packets are being sent.</p>
<p>Hermes can be started to listen for packet events on the two ends of multiple paths and relay packets over these paths.
This can be done over a new path or over existing paths.</p>
<ul>
<li><a href="tutorials/local-chains/relay-paths/./create-new-path.html">Create a new path</a></li>
<li><a href="tutorials/local-chains/relay-paths/./multiple-paths.html">Packet relaying on multiple paths</a></li>
</ul>
<p>Before proceeding to the sections above, please first, make sure you followed the steps in the <a href="tutorials/local-chains/relay-paths/../identifiers.html">Identifiers section</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-new-path"><a class="header" href="#create-a-new-path">Create a new path</a></h1>
<p>Perform client creation, connection and channel handshake to establish a new path between the <code>transfer</code> ports on <code>ibc-0</code> and <code>ibc-1</code> chains.</p>
<pre><code class="language-shell">hermes create channel --a-chain ibc-0 --b-chain ibc-1 --a-port transfer --b-port transfer --new-client-connection
</code></pre>
<p>If all the handshakes are performed successfully you should see a message similar to the one below:</p>
<pre><code class="language-json">Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-1&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-1&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    connection_delay: 0s,
    version: Some(
        &quot;ics20-1&quot;,
    ),
}

</code></pre>
<p>Note that for each side, <em>a_side</em> (<strong>ibc-0</strong>) and <em>b_side</em> (<strong>ibc-1</strong>) there are a <strong>client_id</strong>, <strong>connection_id</strong>, <strong>channel_id</strong> and <strong>port_id</strong>.
With all these established, you have <a href="tutorials/local-chains/relay-paths/./multiple-paths.html">a path that you can relay packets over</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relay-packets-on-multiple-paths"><a class="header" href="#relay-packets-on-multiple-paths">Relay packets on multiple paths</a></h1>
<p>Hermes can relay packets over all current or future paths between the configured set of chains.</p>
<p>Follow the steps below to connect three chains together and relay packets between them:</p>
<ol>
<li>
<p>Add the config for the third chain to the existing <code>$HOME/.gm/gm.toml</code> file</p>
<pre><code class="language-toml">[global]
add_to_hermes = false
auto_maintain_config = true
extra_wallets = 2
gaiad_binary = &quot;~/go/bin/gaiad&quot;
hdpath = &quot;&quot;
home_dir = &quot;$HOME/.gm&quot;
ports_start_at = 27000
validator_mnemonic = &quot;&quot;
wallet_mnemonic = &quot;&quot;

[global.hermes]
    binary = &quot;$HOME/ibc-rs/target/debug/hermes&quot; #change this path according to your setup
    config = &quot;./hermes&quot;
    log_level = &quot;info&quot;
    telemetry_enabled = true
    telemetry_host = &quot;127.0.0.1&quot;
    telemetry_port = 3001

[ibc-0]
ports_start_at = 27010

[ibc-1]
ports_start_at = 27020

[node-0]
add_to_hermes = true
network = &quot;ibc-0&quot;
ports_start_at = 27030

[node-1]
add_to_hermes = true
network = &quot;ibc-1&quot;
ports_start_at = 27040

[ibc-2]
ports_start_at = 27050

[node-2]
add_to_hermes = true
network = &quot;ibc-2&quot;
ports_start_at = 27060
</code></pre>
</li>
<li>
<p>Start the third chain</p>
<pre><code class="language-bash">gm start
</code></pre>
</li>
<li>
<p>Update the <code>$HOME/.hermes/.config.toml</code> file</p>
<pre><code class="language-bash">gm hermes config
</code></pre>
</li>
<li>
<p>Associate the keys to the new chain</p>
<pre><code class="language-bash">gm hermes keys
</code></pre>
</li>
<li>
<p>Check the status of the chains</p>
<pre><code class="language-bash">gm status
</code></pre>
</li>
<li>
<p>Create a channel between <code>ibc-0</code> and <code>ibc-1</code>. Since this is the first time
we're connecting these two chains, we'll need to spin up a client and a
connection between them as well. The <code>create channel</code> command gives us the
convenient option to create a client and a connection. Keep in mind that this
is not the default behavior of <code>create channel</code>, but in this case we're
making an exception. Execute the following command:</p>
<pre><code class="language-shell">hermes create channel --a-chain ibc-0 --b-chain ibc-1 --a-port transfer --b-port transfer --new-client-connection
</code></pre>
<p>Then respond 'yes' to the prompt that pops up. Once the command has run to
completion, you should see the following among the output logs:</p>
<pre><code class="language-json">(...)

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0s,
    version: Some(
        &quot;ics20-1&quot;,
    ),
}
</code></pre>
<p>Note that the channel identifier on both <code>ibc-0</code> and <code>ibc-1</code> is <code>channel-0</code>.</p>
</li>
<li>
<p>Create a channel between <code>ibc-1</code> and <code>ibc-2</code> using the structure of the
previous invocation we used to create a channel between <code>ibc-0</code> and <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes create channel --a-chain ibc-1 --b-chain ibc-2 --a-port transfer --b-port transfer --new-client-connection
</code></pre>
<pre><code class="language-json">(...)

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-1&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-1&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-2&quot;,
                version: 2,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0s,
    version: Some(
        &quot;ics20-1&quot;,
    ),
}
</code></pre>
<p>Note that the channel identifier on <code>ibc-1</code> is <code>channel-1</code>, and on <code>ibc-2</code> it is <code>channel-0</code>.</p>
</li>
<li>
<p>Start Hermes using the <code>start</code> command:</p>
<pre><code class="language-shell">hermes start
</code></pre>
<p>Hermes will first relay the pending packets that have not been relayed and then
start passive relaying by listening to and acting on packet events.</p>
</li>
<li>
<p>In a separate terminal, use the <code>ft-transfer</code> command to send:</p>
<ul>
<li>
<p>Two packets from <code>ibc-0</code> to <code>ibc-1</code> from source channel <code>channel-0</code></p>
<pre><code class="language-shell">hermes tx ft-transfer --receiver-chain ibc-1 --sender-chain ibc-0 --sender-port transfer --sender-channel channel-0 --amount 9999 --timeout-height-offset 1000 --number-msgs 2
</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: revision: 0, height: 3056,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(3),
        },
    ),
    SendPacket(
        SendPacket {
            height: revision: 0, height: 3056,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
        },
    ),
]
</code></pre>
</li>
<li>
<p>Two packets from <code>ibc-1</code> to <code>ibc-2</code> from source channel <code>channel-1</code></p>
<pre><code class="language-shell">hermes tx ft-transfer --receiver-chain ibc-2 --sender-chain ibc-1 --sender-port transfer --sender-channel channel-1 --amount 9999 --timeout-height-offset 1000 --number-msgs 2
</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: revision: 1, height: 3076,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-1&quot;) Sequence(3),
        },
    ),
    SendPacket(
        SendPacket {
            height: revision: 1, height: 3076,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-1&quot;) Sequence(4),
        },
    ),
]
</code></pre>
</li>
</ul>
</li>
<li>
<p>Observe the output on the relayer terminal, verify that the send events are processed, and that the <code>recv_packets</code> are sent out.</p>
<pre><code class="language-text">(...)

INFO ibc_relayer::link: [ibc-0 -&gt; ibc-1] result events:
    UpdateClientEv(ev_h:1-3048, 07-tendermint-0(0-3057), )
    WriteAcknowledgementEv(h:1-3048, seq:3, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
    WriteAcknowledgementEv(h:1-3048, seq:4, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
INFO ibc_relayer::link: [ibc-0 -&gt; ibc-1] success

(...)

INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] clearing old packets
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] received from query_txs []
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] finished clearing pending packets
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] generate messages from batch with 2 events
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] scheduling op. data with 2 msg(s) for Destination chain (height 1-3049)
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] relay op. data to Destination, proofs height 1-3048, (delayed by: 2.154603ms) [try 1/10]
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] prepending Destination client update @ height 1-3049
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] assembled batch of 3 message(s)
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] result events:
    UpdateClientEv(ev_h:0-3059, 07-tendermint-0(1-3049), )
    AcknowledgePacketEv(h:0-3059, seq:3, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
    AcknowledgePacketEv(h:0-3059, seq:4, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] success

(...)
</code></pre>
</li>
<li>
<p>Query the unreceived packets and acknowledgments on <code>ibc-1</code> and <code>ibc-2</code> from a different terminal:</p>
<pre><code class="language-shell">hermes query packet pending-sends --chain ibc-1 --port transfer --channel channel-0
hermes query packet pending-acks --chain ibc-0 --port transfer --channel channel-0
hermes query packet pending-sends --chain ibc-2 --port transfer --channel channel-0
hermes query packet pending-acks --chain ibc-1 --port transfer --channel channel-1
</code></pre>
<p>If everything went well, each of these commands should result in:</p>
<pre><code>Success: []
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>The <code>Commands</code> section presents the commands current available in Hermes</p>
<h2 id="sections-1"><a class="header" href="#sections-1">Sections</a></h2>
<p><strong><a href="commands/./keys/index.html">Keys</a></strong></p>
<p>Commands to manage keys (private keys) for each chain.</p>
<p><strong><a href="commands/./config.html">Config</a></strong></p>
<p>Commands to manage configuration file, in particular to validate it.</p>
<p><strong><a href="commands/./path-setup/index.html">Path Setup</a></strong></p>
<p>Commands to manage clients, connections, channels.</p>
<p><strong><a href="commands/./relaying/index.html">Relaying</a></strong></p>
<p>Commands to start the relayer and relay packets.</p>
<p><strong><a href="commands/./listen/index.html">Listen Mode</a></strong></p>
<p>Commands to listen for IBC events</p>
<p><strong><a href="commands/./upgrade/index.html">Upgrade</a></strong></p>
<p>Commands to perform client upgrade</p>
<p><strong><a href="commands/./misbehaviour/index.html">Monitor</a></strong></p>
<p>Commands to monitor clients and submit evidence of misbehaviour</p>
<p><strong><a href="commands/./queries/index.html">Queries</a></strong></p>
<p>Commands to execute queries on configured chains</p>
<p><strong><a href="commands/./tx/index.html">Transactions</a></strong></p>
<p>Commands to submit individual transactions to configured chains</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-options"><a class="header" href="#global-options">Global options</a></h1>
<p>Hermes accepts <em>global</em> options which affect all commands.</p>
<pre><code class="language-shell">hermes v1.0.0
Informal Systems &lt;hello@informal.systems&gt;
Implementation of `hermes`, an IBC Relayer developed in Rust.

FLAGS:
        --config &lt;CONFIG&gt;    Path to configuration file
        --json               Enable JSON output
</code></pre>
<h2 id="ordering-of-command-line-options"><a class="header" href="#ordering-of-command-line-options">Ordering of command-line options</a></h2>
<p>The global options must be specified right after the <code>hermes</code> command and <em>before</em> any subcommand.
The non-global options have to be specified <em>after</em> the subcommand.</p>
<pre><code class="language-shell">hermes &lt;GLOBAL_OPTIONS&gt; subcommand &lt;OPTIONS&gt;
</code></pre>
<p><strong>Example</strong></p>
<p>To <code>start</code> the relayer using the configuration file at <code>/home/my_chain.toml</code> and enable JSON output:</p>
<pre><code class="language-shell">hermes --config /home/my_chain.toml --json start
</code></pre>
<p>To <code>query</code> all clients on a chain while enabling JSON output:</p>
<pre><code class="language-shell">hermes --json query clients --host-chain ibc-1
</code></pre>
<h2 id="json-output"><a class="header" href="#json-output">JSON output</a></h2>
<p>If the <code>--json</code> option is supplied, all relayer commands will output single-line JSON values instead of plain text.</p>
<p>Log messages will be written to <code>stderr</code>, while the final result will be written to <code>stdout</code>, and everything
will be formatted as JSON.
This allows processing only the final output using <a href="https://stedolan.github.io/jq/"><code>jq</code></a>.
To process all the output using <code>jq</code>, one can redirect <code>stderr</code> to <code>stdout</code> with <code>hermes --json COMMAND 2&gt;&amp;1 | jq</code>.</p>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes --config /home/my_chain.toml --json create client --host-chain ibc-0 --reference-chain ibc-1
</code></pre>
<pre><code class="language-json">{&quot;timestamp&quot;:&quot;Apr 13 20:46:31.921&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;Using default configuration from: '.hermes/config.toml'&quot;},&quot;target&quot;:&quot;ibc_relayer_cli::commands&quot;}
{&quot;timestamp&quot;:&quot;Apr 13 20:46:31.961&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;running listener&quot;,&quot;chain.id&quot;:&quot;ibc-1&quot;},&quot;target&quot;:&quot;ibc_relayer::event::monitor&quot;}
{&quot;timestamp&quot;:&quot;Apr 13 20:46:31.989&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;running listener&quot;,&quot;chain.id&quot;:&quot;ibc-0&quot;},&quot;target&quot;:&quot;ibc_relayer::event::monitor&quot;}
{&quot;result&quot;:{&quot;CreateClient&quot;:{&quot;client_id&quot;:&quot;07-tendermint-1&quot;,&quot;client_type&quot;:&quot;Tendermint&quot;,&quot;consensus_height&quot;:{&quot;revision_height&quot;:10060,&quot;revision_number&quot;:1},&quot;height&quot;:{&quot;revision_height&quot;:10072,&quot;revision_number&quot;:0}}},&quot;status&quot;:&quot;success&quot;}
</code></pre>
<p>The first three lines are printed to <code>stderr</code>, while the last line with a <code>&quot;result&quot;</code> key is printed to <code>stdout</code>.</p>
<p><strong>Example</strong></p>
<p>To improve the readability, pipe all of the output to <code>jq</code>:</p>
<pre><code>hermes --config /home/my_chain.toml --json create client --host-chain ibc-0 --reference-chain ibc-1 2&gt;&amp;1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;timestamp&quot;: &quot;Apr 13 20:52:26.060&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;Using default configuration from: '.hermes/config.toml'&quot;
  },
  &quot;target&quot;: &quot;ibc_relayer_cli::commands&quot;
}
{
  &quot;timestamp&quot;: &quot;Apr 13 20:52:26.082&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;running listener&quot;,
    &quot;chain.id&quot;: &quot;ibc-1&quot;
  },
  &quot;target&quot;: &quot;ibc_relayer::event::monitor&quot;
}
{
  &quot;timestamp&quot;: &quot;Apr 13 20:52:26.088&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;running listener&quot;,
    &quot;chain.id&quot;: &quot;ibc-0&quot;
  },
  &quot;target&quot;: &quot;ibc_relayer::event::monitor&quot;
}
{
  &quot;result&quot;: {
    &quot;CreateClient&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-5&quot;,
      &quot;client_type&quot;: &quot;Tendermint&quot;,
      &quot;consensus_height&quot;: {
        &quot;revision_height&quot;: 10364,
        &quot;revision_number&quot;: 1
      },
      &quot;height&quot;: {
        &quot;revision_height&quot;: 10375,
        &quot;revision_number&quot;: 0
      }
    }
  },
  &quot;status&quot;: &quot;success&quot;
}
</code></pre>
<p><strong>Example</strong></p>
<p>To extract the identifer of the newly created client above:</p>
<pre><code>hermes --config /home/my_chain.toml --json create client --host-chain ibc-0 --reference-chain ibc-1 | jq '.result.CreateClient.client_id'
</code></pre>
<pre><code>&quot;07-tendermint-2&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-keys-to-the-relayer"><a class="header" href="#adding-keys-to-the-relayer">Adding Keys to the Relayer</a></h1>
<blockquote>
<p><strong>WARNING</strong>: Currently the relayer does NOT support a <code>keyring</code> store to securely
store the private key file. The key file will be stored on the local file system
in the user <strong>$HOME</strong> folder under <code>$HOME/.hermes/keys/</code></p>
</blockquote>
<blockquote>
<p><strong>BREAKING</strong>: As of Hermes v1.0.0, the sub-command <code>keys restore</code> has been removed.
Please use the sub-command <code>keys add</code> in order to restore a key.</p>
</blockquote>
<hr />
<p>Using the <code>keys</code> command you can add and list keys. </p>
<h4 id="show-usage"><a class="header" href="#show-usage">Show usage</a></h4>
<p>To see the available sub-commands for the <code>keys</code> command run:</p>
<pre><code class="language-shell">hermes help keys
</code></pre>
<p>The available sub-commands are the following:</p>
<pre><code class="language-shell">USAGE:
    hermes keys &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Manage keys in the relayer for each chain

SUBCOMMANDS:
    help       Get usage information
    add        Adds key to a configured chain or restores a key to a configured chain
                    using a mnemonic
    balance    Query balance for a key from a configured chain. If no key is given, the
                    key is retrieved from the configuration file
    delete     Delete key(s) from a configured chain
    list       List keys configured on a chain
</code></pre>
<h3 id="key-seed-file-private-key"><a class="header" href="#key-seed-file-private-key">Key Seed file (Private Key)</a></h3>
<p>In order to execute the command below you need a private key file (JSON). The relayer uses the private key file to sign the transactions submitted to the chain.</p>
<p>The private key file can be obtained by using the <code>keys add</code> on a Cosmos chain. For example, the command for <code>gaiad</code> is:</p>
<pre><code class="language-shell"># The `key_name` parameter is the name of the key that will be found in the json output
# For example, in the &quot;Two Local Chains&quot; tutorial, we use &quot;testkey&quot;.
gaiad keys add &lt;key_name&gt; --output json
</code></pre>
<p>The command outputs a JSON similar to the one below. </p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;testkey&quot;,
  &quot;type&quot;: &quot;local&quot;,
  &quot;address&quot;: &quot;cosmos1tc3vcuxyyac0dmayf887t95tdg7qpyql48w7gj&quot;,
  &quot;pubkey&quot;: &quot;cosmospub1addwnpepqgg7ng4ycm60pdxfzdfh4hjvkwcr3da59mr8k883vsstx60ruv7kur4525u&quot;,
  &quot;mnemonic&quot;: &quot;[24 words mnemonic]&quot;
}
</code></pre>
<p>You can save this to a file (e.g. <code>key_seed.json</code>) and use it to add to the relayer with <code>hermes keys add --chain &lt;chain_id&gt; --key-file key_seed.json</code>. See the <code>Adding Keys</code> section for more details.</p>
<h3 id="adding-and-restoring-keys"><a class="header" href="#adding-and-restoring-keys">Adding and restoring Keys</a></h3>
<p>The command <code>keys add</code> has two exclusive flags, <code>--key-file</code> and <code>--mnemonic-file</code> which are respectively used to add and restore a key.<br />
If a key with the same <code>key_name</code> already exists, the flag <code>--overwrite</code> must be passed in order to overwrite the existing key or else the command will abort.</p>
<pre><code class="language-shell">    hermes keys add [OPTIONS] --chain &lt;CHAIN_ID&gt; --key-file &lt;KEY_FILE&gt;

    hermes keys add [OPTIONS] --chain &lt;CHAIN_ID&gt; --mnemonic-file &lt;MNEMONIC_FILE&gt;

DESCRIPTION:
    Adds key to a configured chain or restores a key to a configured chain using a mnemonic

OPTIONS:
        --hd-path &lt;HD_PATH&gt;      Derivation path for this key [default: m/44'/118'/0'/0/0]
        --key-name &lt;KEY_NAME&gt;    Name of the key (defaults to the `key_name` defined in the config)
        --overwrite              Overwrite the key if there is already one with the same key name

FLAGS:
        --chain &lt;CHAIN_ID&gt;                 Identifier of the chain
        --key-file &lt;KEY_FILE&gt;              Path to the key file
        --mnemonic-file &lt;MNEMONIC_FILE&gt;    Path to file containing mnemonic to restore the key from
</code></pre>
<h4 id="add-a-private-key-to-a-chain-from-a-key-file"><a class="header" href="#add-a-private-key-to-a-chain-from-a-key-file">Add a private key to a chain from a key file</a></h4>
<pre><code class="language-shell">    hermes keys add [OPTIONS] --chain &lt;CHAIN_ID&gt; --key-file &lt;KEY_FILE&gt;

DESCRIPTION:
    Adds key to a configured chain or restores a key to a configured chain using a mnemonic

OPTIONS:
        --hd-path &lt;HD_PATH&gt;      Derivation path for this key [default: m/44'/118'/0'/0/0]
        --key-name &lt;KEY_NAME&gt;    Name of the key (defaults to the `key_name` defined in the config)
        --overwrite              Overwrite the key if there is already one with the same key name

FLAGS:
        --chain &lt;CHAIN_ID&gt;                 Identifier of the chain
        --key-file &lt;KEY_FILE&gt;              Path to the key file
</code></pre>
<p>To add a private key file to a chain:</p>
<pre><code class="language-shell">hermes --config config.toml keys add --chain [CHAIN_ID] --key-file [PRIVATE_KEY_FILE]
</code></pre>
<p>The content of the file key should have the same format as the output of the <code>gaiad keys add</code> command:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;testkey&quot;,
  &quot;type&quot;: &quot;local&quot;,
  &quot;address&quot;: &quot;cosmos1tc3vcuxyyac0dmayf887t95tdg7qpyql48w7gj&quot;,
  &quot;pubkey&quot;: &quot;cosmospub1addwnpepqgg7ng4ycm60pdxfzdfh4hjvkwcr3da59mr8k883vsstx60ruv7kur4525u&quot;,
  &quot;mnemonic&quot;: &quot;[24 words mnemonic]&quot;
}
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">Success: Added key testkey ([ADDRESS]) on [CHAIN ID] chain
</code></pre>
<blockquote>
<p><strong>Key name:</strong>
By default, the key will be named after the <code>key_name</code> property specified in the configuration file.
To use a different key name, specify the <code>--key-name</code> option when invoking <code>keys add</code>.</p>
<pre><code>hermes --config config.toml keys add --chain [CHAINID] --key-file [PRIVATE_KEY_FILE] --key-name [KEY_NAME]
</code></pre>
</blockquote>
<h4 id="restore-a-private-key-to-a-chain-from-a-mnemonic"><a class="header" href="#restore-a-private-key-to-a-chain-from-a-mnemonic">Restore a private key to a chain from a mnemonic</a></h4>
<pre><code class="language-shell">    hermes keys add [OPTIONS] --chain &lt;CHAIN_ID&gt; --mnemonic-file &lt;MNEMONIC_FILE&gt;

DESCRIPTION:
    Adds key to a configured chain or restores a key to a configured chain using a mnemonic

OPTIONS:
        --hd-path &lt;HD_PATH&gt;      Derivation path for this key [default: m/44'/118'/0'/0/0]
        --key-name &lt;KEY_NAME&gt;    Name of the key (defaults to the `key_name` defined in the config)
        --overwrite              Overwrite the key if there is already one with the same key name

FLAGS:
        --chain &lt;CHAIN_ID&gt;                 Identifier of the chain
        --mnemonic-file &lt;MNEMONIC_FILE&gt;    Path to file containing mnemonic to restore the key from
</code></pre>
<p>To restore a key from its mnemonic:</p>
<pre><code class="language-shell">hermes --config config.toml keys add --chain [CHAIN_ID] --mnemonic-file &quot;[MNEMONIC_FILE]&quot;
</code></pre>
<p>or using an explicit <a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">derivation path</a>, for example
an Ethereum coin type (used for Evmos, Injective, Umee, Cronos, and
possibly other networks):</p>
<pre><code class="language-shell">hermes --config config.toml keys add --chain &lt;CHAIN_ID&gt; --mnemonic-file &lt;MNEMONIC_FILE&gt; --hd-path &quot;m/44'/60'/0'/0/0&quot;
</code></pre>
<p>The mnemonic file needs to have the 24 mnemonic words on the same line, separated by a white space. So the content should have the following format:</p>
<pre><code>word1 word2 word3 ... word24
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">Success: Restore key testkey ([ADDRESS]) on [CHAIN ID] chain
</code></pre>
<blockquote>
<p><strong>Key name:</strong>
By default, the key will be named after the <code>key_name</code> property specified in the configuration file.
To use a different key name, specify the <code>--key-name</code> option when invoking <code>keys add</code>.</p>
<pre><code>hermes --config config.toml keys add --chain [CHAINID] --mnemonic-file &quot;[MNEMONIC_FILE]&quot; --key-name [KEY_NAME]
</code></pre>
</blockquote>
<h3 id="delete-keys"><a class="header" href="#delete-keys">Delete keys</a></h3>
<p>In order to delete the private keys added to chains use the <code>keys delete</code> command</p>
<pre><code class="language-shell">USAGE:
    hermes keys delete [OPTIONS] --chain &lt;CHAIN_ID&gt;

DESCRIPTION:
    hermes keys delete --chain &lt;CHAIN_ID&gt; --key-name &lt;KEY_NAME&gt;

    hermes keys delete --chain &lt;CHAIN_ID&gt; --all

FLAGS:
        --all                    Delete all keys
        --chain &lt;CHAIN_ID&gt;       Identifier of the chain
        --key-name &lt;KEY_NAME&gt;    Name of the key
</code></pre>
<h4 id="delete-private-keys-that-was-previously-added-to-a-chain"><a class="header" href="#delete-private-keys-that-was-previously-added-to-a-chain">Delete private keys that was previously added to a chain</a></h4>
<p>To delete a single private key by name:</p>
<pre><code class="language-shell">hermes --config config.toml keys delete --chain [CHAIN_ID] --key-name [KEY_NAME]
</code></pre>
<p>Alternatively, to delete all private keys added to a chain:</p>
<pre><code class="language-shell">hermes --config config.toml keys delete --chain [CHAIN_ID] --all
</code></pre>
<h3 id="list-keys"><a class="header" href="#list-keys">List keys</a></h3>
<p>In order to list the private keys added to chains use the <code>keys list</code> command</p>
<pre><code class="language-shell">USAGE:
    hermes keys list --chain &lt;CHAIN_ID&gt;

DESCRIPTION:
    List keys configured on a chain

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain
</code></pre>
<h4 id="listing-the-private-key-that-was-added-to-a-chain"><a class="header" href="#listing-the-private-key-that-was-added-to-a-chain">Listing the private key that was added to a chain</a></h4>
<p>To list the private key file that was added to a chain:</p>
<pre><code class="language-shell">hermes --config config.toml keys list --chain [CHAIN_ID]
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code>Success:
- user2 (cosmos1attn9fxrcvjz483w3tu4cfz77ldmlyujly3q3k)
- testkey (cosmos1dw88vdekeeuta5u50p6n5lt5v5c6y2we0pu8nz)
</code></pre>
<p><strong>JSON:</strong></p>
<pre><code class="language-shell">hermes --json --config config.toml keys list --chain [CHAIN_ID] | jq
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">{
  &quot;result&quot;: {
    &quot;testkey&quot;: {
      &quot;account&quot;: &quot;cosmos1dw88vdekeeuta5u50p6n5lt5v5c6y2we0pu8nz&quot;,
      &quot;address&quot;: [ 107, 142, 118, 55, 54, 206, 120, 190, 211, 148, 120, 117, 58, 125, 116, 101, 49, 162, 41, 217 ],
      &quot;coin_type&quot;: 118,
      &quot;private_key&quot;: &quot;(snip)&quot;,
      &quot;public_key&quot;: &quot;xpub6Gc7ZUt2q1BiQYjhUextPv5bZLwosHigZYqEquPD6FkAGmHDrLiBgE5Xnh8XGZp79rAXtZn1Dt3DNQHxxgCgVQqfRMfVsRiXn6mwULBnYq7&quot;
    },
    &quot;user2&quot;: {
      &quot;account&quot;: &quot;cosmos1attn9fxrcvjz483w3tu4cfz77ldmlyujly3q3k&quot;,
      &quot;address&quot;: [ 234, 215, 50, 164, 195, 195, 36, 42, 158, 46, 138, 249, 92, 36, 94, 247, 219, 191, 147, 146 ],
      &quot;coin_type&quot;: 118,
      &quot;private_key&quot;: &quot;(snip)&quot;,
      &quot;public_key&quot;: &quot;xpub6FmDbeGTWVjSvHrqHfrpnMTZxpPX1V7XFiq5nMuvgwX9jumt1yUuwNAUQo8Nn36unbFShg6iSjkfMBgeY49wik7rF91N2SHvarpX62ByWMf&quot;
    }
  },
  &quot;status&quot;: &quot;success&quot;
}
</code></pre>
<h3 id="query-balance"><a class="header" href="#query-balance">Query balance</a></h3>
<p>In order to retrieve the balance of an account associated with a key use the <code>keys balance</code> command</p>
<pre><code class="language-shell">USAGE:
    hermes keys balance [OPTIONS] --chain &lt;CHAIN_ID&gt;

DESCRIPTION:
    Query balance for a key from a configured chain. If no key is given, the key is retrieved from the configuration file

OPTIONS:
        --key-name &lt;KEY_NAME&gt;    (optional) name of the key (defaults to the `key_name` defined in
                                 the config)

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain
</code></pre>
<p>If the command is successful a message with the following format will be displayed:</p>
<pre><code>Success: balance for key `KEY_NAME`: 100000000000 stake
</code></pre>
<p><strong>JSON:</strong></p>
<pre><code class="language-shell">hermes --json keys balance [OPTIONS] --chain &lt;CHAIN_ID&gt;
</code></pre>
<p>If the command is successful a message with the following format will be displayed:</p>
<pre><code class="language-json">{
  &quot;result&quot;: {
    &quot;amount&quot;: &quot;99989207&quot;,
    &quot;denom&quot;: &quot;stake&quot;
  },
  &quot;status&quot;: &quot;success&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="config"><a class="header" href="#config">Config</a></h1>
<p>Use the <code>config validate</code> command to perform a quick syntactic validation of
your configuration file.</p>
<pre><code class="language-shell">USAGE:
    hermes config validate

DESCRIPTION:
    validate the relayer configuration
</code></pre>
<p><strong>Example</strong></p>
<p>Validate the default config file, the path inferred automatically to be
<code>$HOME/.hermes/config.toml</code>.</p>
<pre><code class="language-shell">hermes config validate
</code></pre>
<pre><code class="language-text">hermes config validate
Jul 12 16:31:07.017  INFO using default configuration from '$HOME/.hermes/config.toml'
Success: &quot;validation passed successfully&quot;
</code></pre>
<p>Validate a config file at an arbitrary location:</p>
<pre><code class="language-shell">hermes --config ./config.toml config validate
</code></pre>
<p>This one fails validation because we mistakenly added two separate sections for
the same chain <code>ibc-1</code>:</p>
<pre><code class="language-text">hermes --config ./config.toml config validate
error: hermes fatal error: config error: config file has duplicate entry for the chain 'ibc-1'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-setup"><a class="header" href="#path-setup">Path Setup</a></h1>
<p>This section describes a number of commands that can be used to manage clients, connections, channels.</p>
<div class="table-wrapper"><table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>create client</code></td><td><a href="commands/path-setup/./clients.html#create-client">Create a client for source chain on destination chain</a></td></tr>
<tr><td><code>update client</code></td><td><a href="commands/path-setup/./clients.html#md-client">Update the specified client on destination chain</a></td></tr>
<tr><td><code>create connection</code></td><td><a href="commands/path-setup/./connections.html#establish-connection">Establish a connection using existing or new clients</a></td></tr>
<tr><td><code>create channel</code></td><td><a href="commands/path-setup/./channels.html#establish-channel">Establish a channel using a pre-existing connection, or alternatively create a new client and a new connection underlying the new channel</a></td></tr>
</tbody></table>
</div>
<h2 id="create"><a class="header" href="#create">Create</a></h2>
<p>Use the <code>create</code> commands to create new clients, connections, and channels.</p>
<pre><code class="language-shell">USAGE:
    hermes create &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Create objects (client, connection, or channel) on chains

SUBCOMMANDS:
    channel       Create a new channel between two chains using a pre-existing connection
    client        Create a new IBC client
    connection    Create a new connection between two chains
    help          Print this message or the help of the given subcommand(s)
</code></pre>
<h2 id="update"><a class="header" href="#update">Update</a></h2>
<p>Use the <code>update</code> commands to update a client.</p>
<pre><code class="language-shell">USAGE:
    hermes update &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Update objects (clients) on chains

SUBCOMMANDS:
    help       Get usage information
    client     Update an IBC client
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client"><a class="header" href="#client">Client</a></h1>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="commands/path-setup/clients.html#create-client">Create Client</a></li>
<li><a href="commands/path-setup/clients.html#update-client">Update Client</a></li>
</ul>
<h2 id="create-client"><a class="header" href="#create-client">Create Client</a></h2>
<p>Use the <code>create client</code> command to create a new client on a destination chain,
tracking the state of the source chain.</p>
<pre><code class="language-shell">USAGE:
    hermes create client [OPTIONS] --host-chain &lt;HOST_CHAIN_ID&gt; --reference-chain &lt;REFERENCE_CHAIN_ID&gt;

DESCRIPTION:
    Create a new IBC client

OPTIONS:
        --clock-drift &lt;CLOCK_DRIFT&gt;
            The maximum allowed clock drift for this client.

            The clock drift is a correction parameter. It helps deal with clocks that are only
            approximately synchronized between the source and destination chains of this client. The
            destination chain for this client uses the clock drift parameter when deciding to accept
            or reject a new header (originating from the source chain) for this client. If this
            option is not specified, a suitable clock drift value is derived from the chain
            configurations.

        --trust-threshold &lt;TRUST_THRESHOLD&gt;
            Override the trust threshold specified in the configuration.

            The trust threshold defines what fraction of the total voting power of a known and
            trusted validator set is sufficient for a commit to be accepted going forward.

        --trusting-period &lt;TRUSTING_PERIOD&gt;
            Override the trusting period specified in the config.

            The trusting period specifies how long a validator set is trusted for (must be shorter
            than the chain's unbonding period).

REQUIRED:
        --host-chain &lt;HOST_CHAIN_ID&gt;
            Identifier of the chain that hosts the client

        --reference-chain &lt;REFERENCE_CHAIN_ID&gt;
            Identifier of the chain targeted by the client
</code></pre>
<p><strong>Example</strong></p>
<p>Create a new client on <code>ibc-0</code> which tracks <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes create client --host-chain ibc-0 --reference-chain ibc-1
</code></pre>
<pre><code class="language-json">    CreateClient(
        Attributes {
            height: Height {
                revision: 0,
                height: 286,
            },
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 1,
                height: 274,
            },
        },
    ),
)
</code></pre>
<p>A new client is created with identifier <code>07-tendermint-1</code></p>
<h2 id="update-client"><a class="header" href="#update-client">Update Client</a></h2>
<p>Use the <code>update client</code> command to update an existing client with a new consensus state.
Specific update and trusted heights can be specified.</p>
<pre><code class="language-shell">USAGE:
    hermes update client [OPTIONS] --host-chain &lt;HOST_CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

DESCRIPTION:
    Update an IBC client

OPTIONS:
        --height &lt;REFERENCE_HEIGHT&gt;
            The target height of the client update. Leave unspecified for latest height.

        --trusted-height &lt;REFERENCE_TRUSTED_HEIGHT&gt;
            The trusted height of the client update. Leave unspecified for latest height.

REQUIRED:
        --client &lt;CLIENT_ID&gt;            Identifier of the chain targeted by the client
        --host-chain &lt;HOST_CHAIN_ID&gt;    Identifier of the chain that hosts the client
</code></pre>
<p><strong>Update client with latest header</strong></p>
<p>the client on <code>ibc-0</code> with latest header of <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes update client --host-chain ibc-0 --client 07-tendermint-9
</code></pre>
<pre><code class="language-json">Success: UpdateClient(
    UpdateClient {
        common: Attributes {
            height: Height { revision: 0, height: 303 },
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 293 },
        },
        header: Some(
            Tendermint(
                 Header {...},
            ),
        ),
    },
)
</code></pre>
<p>The client with identifier <code>07-tendermint-1</code> has been updated with the consensus state at height <code>1-293</code>.</p>
<p><strong>Update a client to a specific target height</strong></p>
<pre><code class="language-shell">hermes update client --host-chain ibc-0 --client 07-tendermint-1 --height 320 --trusted-height 293
</code></pre>
<pre><code class="language-json">Success: UpdateClient(
    UpdateClient {
        common: Attributes {
            height: Height { revision: 0, height: 555 },
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 320 },
        },
        header: Some(
            Tendermint(
                 Header {...},
            ),
        ),
    },
)
</code></pre>
<p>The client with identifier <code>07-tendermint-1</code> has been updated with the consensus state at height <code>1-320</code>, as specified.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection"><a class="header" href="#connection">Connection</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="commands/path-setup/connections.html#establish-connection">Establish Connection</a></li>
<li><a href="commands/path-setup/connections.html#examples">Examples</a>
<ul>
<li><a href="commands/path-setup/connections.html#new-connection-over-new-clients">New connection over new clients</a></li>
<li><a href="commands/path-setup/connections.html#new-connection-over-existing-clients">New connection over existing clients</a></li>
</ul>
</li>
<li><a href="commands/path-setup/connections.html#non-zero-delay-connection">Non-zero Delay Connection</a></li>
</ul>
<h2 id="establish-connection"><a class="header" href="#establish-connection">Establish Connection</a></h2>
<p>Use the <code>create connection</code> command to create a new connection.</p>
<pre><code class="language-shell">USAGE:
    hermes create connection [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --b-chain &lt;B_CHAIN_ID&gt;

    hermes create connection [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --a-client &lt;A_CLIENT_ID&gt; --b-client &lt;B_CLIENT_ID&gt;

DESCRIPTION:
    Create a new connection between two chains

OPTIONS:
        --delay &lt;DELAY&gt;    Delay period parameter for the new connection (seconds) [default: 0]

FLAGS:
        --a-chain &lt;A_CHAIN_ID&gt;      Identifier of the side `a` chain for the new connection
        --a-client &lt;A_CLIENT_ID&gt;    Identifier of client hosted on chain `a`; default: None (creates
                                    a new client)
        --b-chain &lt;B_CHAIN_ID&gt;      Identifier of the side `b` chain for the new connection
        --b-client &lt;B_CLIENT_ID&gt;    Identifier of client hosted on chain `b`; default: None (creates
                                    a new client)
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="new-connection-over-new-clients"><a class="header" href="#new-connection-over-new-clients">New connection over new clients</a></h3>
<p>Create a new connection between <code>ibc-0</code> and <code>ibc-1</code> over new clients:</p>
<pre><code class="language-shell">hermes create connection --a-chain ibc-0 --b-chain ibc-1
</code></pre>
<pre><code class="language-json">🥂  ibc-0 =&gt; OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 4073 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 4069 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂  ibc-0 =&gt; OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 4081 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 4073 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂🥂🥂  Connection handshake finished for [Connection {
    delay_period: 0s,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
}]

Success: Connection {
    delay_period: 0s,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
}
</code></pre>
<h3 id="new-connection-over-existing-clients"><a class="header" href="#new-connection-over-existing-clients">New connection over existing clients</a></h3>
<p>Create a new connection between <code>ibc-0</code> and <code>ibc-1</code> over existing clients,
both with client id <code>07-tendermint-0</code>:</p>
<pre><code class="language-shell">hermes create connection --a-chain ibc-0 --a-client 07-tendermint-0 --b-client 07-tendermint-0
</code></pre>
<p>Notice that one can omit the destination chain parameter, as Hermes will automatically
figure it out by looking up the given client on <code>ibc-0</code>.</p>
<h2 id="non-zero-delay-connection"><a class="header" href="#non-zero-delay-connection">Non-zero Delay Connection</a></h2>
<p>A connection can be created with a delay period parameter. This parameter specifies a period of time that must elpase after a successful client state update and before a packet with proofs using its commitment root can pe processed on chain. For more information see <a href="commands/path-setup/../relaying/index.html#packet-delay">how packet delay works</a> and the <a href="https://github.com/cosmos/ibc/tree/master/spec/core/ics-003-connection-semantics">connection delay specification</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel"><a class="header" href="#channel">Channel</a></h1>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of Contents</a></h2>
<ul>
<li><a href="commands/path-setup/channels.html#establish-channel">Establish Channel</a></li>
<li><a href="commands/path-setup/channels.html#examples">Examples</a>
<ul>
<li><a href="commands/path-setup/channels.html#new-channel-over-an-existing-connection">New channel over an existing connection</a></li>
<li><a href="commands/path-setup/channels.html#new-channel-over-a-new-connection">New channel over a new connection</a></li>
</ul>
</li>
</ul>
<h2 id="establish-channel"><a class="header" href="#establish-channel">Establish Channel</a></h2>
<p>Use the <code>create channel</code> command to establish a new channel.</p>
<pre><code class="language-shell">USAGE:
    hermes create channel [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --a-connection &lt;A_CONNECTION_ID&gt; --a-port &lt;A_PORT_ID&gt; --b-port &lt;B_PORT_ID&gt;

    hermes create channel [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --b-chain &lt;B_CHAIN_ID&gt; --a-port &lt;A_PORT_ID&gt; --b-port &lt;B_PORT_ID&gt; --new-client-connection

DESCRIPTION:
    Create a new channel between two chains.

    Can create a new channel using a pre-existing connection or alternatively, create a new client and a
    new connection underlying the new channel if a pre-existing connection is not provided.

OPTIONS:
        --channel-version &lt;VERSION&gt;
            The version for the new channel

            [aliases: chan-version]

        --new-client-connection
            Indicates that a new client and connection will be created underlying the new channel

            [aliases: new-client-conn]

        --order &lt;ORDER&gt;
            The channel ordering, valid options 'unordered' (default) and 'ordered'

            [default: ORDER_UNORDERED]

        --yes
            Skip new_client_connection confirmation

FLAGS:
        --a-chain &lt;A_CHAIN_ID&gt;
            Identifier of the side `a` chain for the new channel

        --a-connection &lt;A_CONNECTION_ID&gt;
            Identifier of the connection on chain `a` to use in creating the new channel

            [aliases: a-conn]

        --a-port &lt;A_PORT_ID&gt;
            Identifier of the side `a` port for the new channel

        --b-chain &lt;B_CHAIN_ID&gt;
            Identifier of the side `b` chain for the new channel

        --b-port &lt;B_PORT_ID&gt;
            Identifier of the side `b` port for the new channel
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="new-channel-over-an-existing-connection"><a class="header" href="#new-channel-over-an-existing-connection">New channel over an existing connection</a></h3>
<p>This is the preferred way to create a new channel, by leveraging an existing
connection.</p>
<p>Create a new unordered channel between <code>ibc-0</code> and <code>ibc-1</code> over an existing connection,
specifically the one we just created in the example above, with port name
<code>transfer</code> on both sides:</p>
<pre><code class="language-shell">hermes create channel --a-chain ibc-0 --a-connection connection-0 --a-port transfer --b-port transfer --order unordered
</code></pre>
<p>Notice that one can omit the destination chain parameter, as Hermes will automatically
figure it out by looking up the given connection on <code>ibc-0</code>.</p>
<pre><code class="language-json">🥳  ibc-0 =&gt; OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 129 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: None
        }
    )
)
🥳  ibc-1 =&gt; OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 126 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-1&quot;))
        }
    )
)
🥳  ibc-0 =&gt; OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 137 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-1&quot;))
        }
    )
)
🥳  ibc-1 =&gt; OpenConfirmChannel(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 129 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-1&quot;))
        }
    )
)
🥳  🥳  🥳  Channel handshake finished for Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    connection_delay: 0s,
}
Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    connection_delay: 0s,
}
</code></pre>
<h3 id="new-channel-over-a-new-connection"><a class="header" href="#new-channel-over-a-new-connection">New channel over a new connection</a></h3>
<p>Should you specifically want to create a new client and a new connection as part
of the <code>create channel</code> flow, that option exists, though this is the
less-preferred option over the previous flow, as creating new clients and
connections should only be done in certain specific circumstances so as not to
create redundant resources.</p>
<p>Create a new unordered channel between <code>ibc-0</code> and <code>ibc-1</code> over a new
connection, using port name <code>transfer</code> on both sides and accepting the
interactive prompt that pops up notifying you that a new client and a new
connection will be initialized as part of the process:</p>
<pre><code class="language-shell">hermes create channel --a-chain ibc-0 --b-chain ibc-1 --a-port transfer --b-port transfer --order unordered --new-client-connection
</code></pre>
<pre><code class="language-json">🥂  ibc-0 =&gt; OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 66 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 64 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂  ibc-0 =&gt; OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 76 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 68 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂🥂🥂  Connection handshake finished for [Connection {
    delay_period: 0s,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
    },
}]

🥳  ibc-0 =&gt; OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 78 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: None
        }
    )
)

🥳  ibc-1 =&gt; OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 70 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-0&quot;))
        }
    )
)

🥳  ibc-0 =&gt; OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 81 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-0&quot;))
        }
    )
)

🥳  ibc-1 =&gt; OpenConfirmChannel
    OpenConfirm
        Attributes {
            height: Height { revision: 1, height: 73 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-0&quot;))
        }
    )
)

🥳  🥳  🥳  Channel handshake finished for Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0s,
}

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0s,
}
</code></pre>
<p>A new channel with identifier <code>channel-0</code> on both sides has been established on
a new connection with identifier <code>connection-0</code> on both sides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relaying"><a class="header" href="#relaying">Relaying</a></h1>
<p>This section describes the types of relaying that hermes can perform.</p>
<p>Hermes can send transactions triggered by IBC events. It currently handles channel handshake and packet events:</p>
<ul>
<li><a href="commands/relaying/./packets.html#packet-relaying">packets messages only</a></li>
<li><a href="commands/relaying/./handshakes.html">channel and packet messages</a></li>
</ul>
<h2 id="the-start-command"><a class="header" href="#the-start-command">The <code>start</code> Command</a></h2>
<p>The <code>start</code> command can be used to start hermes in IBC event listen mode.</p>
<pre><code class="language-shell">USAGE:
    hermes start [OPTIONS]

DESCRIPTION:
    Start the relayer in multi-chain mode.

    Relays packets and open handshake messages between all chains in the config.

OPTIONS:
        --full-scan    Force a full scan of the chains for clients, connections and channels
</code></pre>
<p>As described in next sub-sections, the type of relaying can be configured in the <code>global</code> section of the configuration file, by specifying different values in <code>strategy</code> field.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-relaying"><a class="header" href="#packet-relaying">Packet Relaying</a></h1>
<p>This section describes the configuration and commands that can be used to start the relayer and relay packets over one or multiple paths.</p>
<h2 id="table-of-contents-6"><a class="header" href="#table-of-contents-6">Table of Contents</a></h2>
<ul>
<li><a href="commands/relaying/packets.html#the-start-command">The <code>start</code> Command</a></li>
<li><a href="commands/relaying/packets.html#packet-streaming">Packet Streaming</a></li>
<li><a href="commands/relaying/packets.html#packet-delay">Packet Delay</a></li>
</ul>
<h2 id="the-start-command-1"><a class="header" href="#the-start-command-1">The <code>start</code> Command</a></h2>
<p>To relay packets only configure the <code>mode</code> section of the configuration file like so:</p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
# ...

[mode.connections]
enabled = false

[mode.channels]
enabled = false

[mode.packets]
enabled = true
# ...
</code></pre>
<p>Then start hermes using the start command:</p>
<pre><code class="language-shell">hermes start
</code></pre>
<p>The relayer sends packet transactions triggered by IBC packet events for all open channels between the configured chains.
This is also referred to packet streaming.</p>
<h2 id="packet-streaming"><a class="header" href="#packet-streaming">Packet Streaming</a></h2>
<p>After the relayer is started using the <code>start</code> command, it listens to IBC packet events emitted by any of
the configured chains. Assuming the events are coming from a <code>source</code> chain, the relayer builds packets
based on these events, packets that are then sent either to the <code>source</code> chain or the counterparty (<code>destination</code>) chain.</p>
<p>Current events and actions are:</p>
<ul>
<li><code>send_packet</code>: the relayer builds a packet message with the <code>packet</code> obtained from the event and any required proofs obtained from the counterparty of the chain where the message is sent. The concrete packet is:
<ul>
<li><code>MsgRecvPacket</code>, sent to <code>destination</code> chain if the channel is in open state on the <code>destination</code> chain, and a timeout has not occurred,</li>
<li><code>MsgTimeout</code>, sent to the <code>source</code> chain if the channel is in open state on the <code>destination</code> chain, but a timeout has occurred.</li>
<li><code>MsgTimeoutOnClose</code>, sent to the <code>source</code> chain if the channel is in closed state on the <code>destination</code> chain.</li>
</ul>
</li>
<li><code>write_acknowledgement</code>: the relayer builds a <code>MsgAcknowledgement</code> packet that is sent to the <code>destination</code> chain.</li>
</ul>
<p>In addition to these events, the relayer will also handle channel closing events:</p>
<ul>
<li><code>chan_close_init</code>: the relayer builds a <code>MsgChannelCloseConfirm</code> and sends it to the <code>destination</code> chain</li>
</ul>
<h2 id="packet-delay"><a class="header" href="#packet-delay">Packet Delay</a></h2>
<p>If the relay path is using a non-zero delay connection, then <code>hermes</code> will delay all packet transactions. The delay is relative to the submission time for the client update at the height required by the packet proof.
The delay is used to prevent light client attacks and ensures that misbehavior detection finalizes before the transaction is submitted.
For more information on the misbehavior detector see <a href="commands/relaying/../misbehaviour/index.html#monitoring-misbehaviour-and-evidence-submission">the misbehaviour section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relaying-of-handshake-messages"><a class="header" href="#relaying-of-handshake-messages">Relaying of Handshake Messages</a></h1>
<p>This section describes the configuration and commands that can be used to start the relayer and relay both handshake and packets
for connections and channels.</p>
<h2 id="the-start-command-2"><a class="header" href="#the-start-command-2">The <code>start</code> Command</a></h2>
<p>To relay packets and handshake messages configure the <code>mode</code> section of the configuration file like so:</p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
# ...

[mode.connections]
enabled = true

[mode.channels]
enabled = true

[mode.packets]
enabled = true
# ...
</code></pre>
<p>Then start hermes using the start command:</p>
<pre><code class="language-shell">hermes start
</code></pre>
<p>The relayer sends handshake and packet transactions triggered by IBC events.</p>
<h2 id="completing-channel-handshakes"><a class="header" href="#completing-channel-handshakes">Completing Channel Handshakes</a></h2>
<p>After the relayer is started using the <code>start</code> command, it scans the chain state and will resume the handshake for any
channels or connections that are not in open state. It then listens to IBC events emitted by any of
the configured chains.</p>
<p>Assuming the events are coming from a <code>source</code> chain, the relayer determines the <code>destination</code> chain and builds the handshake messages based on these events. These are then sent to the <code>destination</code> chain.</p>
<p>In addition to the events described in <a href="commands/relaying/packets.html#packet-relaying">Packet Relaying</a>, the following IBC events may be handled:</p>
<ul>
<li>
<p>Channels (if <code>mode.channels.enabled=true</code>):</p>
<ul>
<li><code>chan_open_init</code>: the relayer builds a <code>MsgChannelOpenTry</code> message</li>
<li><code>chan_open_try</code>: the relayer builds a <code>MsgChannelOpenAck</code> message</li>
<li><code>chan_open_ack</code>: the relayer builds a <code>MsgChannelOpenConfirm</code> message</li>
<li><code>chan_open_confirm</code>: no message is sent out, channel opening is finished</li>
</ul>
</li>
<li>
<p>Connections (if <code>mode.connections.enabled=true</code>):</p>
<ul>
<li><code>conn_open_init</code>: the relayer builds a <code>MsgConnOpenTry</code> message</li>
<li><code>conn_open_try</code>: the relayer builds a <code>MsgConnOpenAck</code> message</li>
<li><code>conn_open_ack</code>: the relayer builds a <code>MsgConnOpenConfirm</code> message</li>
<li><code>conn_open_confirm</code>: no message is sent out, connection opening is finished</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clearing-packets"><a class="header" href="#clearing-packets">Clearing Packets</a></h1>
<h2 id="clear-packets"><a class="header" href="#clear-packets"><code>clear packets</code></a></h2>
<p>This command clears outstanding packets on a given channel in both directions,
by issuing the appropriate <a href="commands/relaying/../tx/packet.html#relay-receive-and-timeout-packets">packet-recvs</a>
and <a href="commands/relaying/../tx/packet.html#relay-acknowledgment-packets">packet-acks</a>.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code>USAGE:
    hermes clear packets [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

DESCRIPTION:
    Clear outstanding packets (i.e., packet-recv and packet-ack) on a given channel in both directions.
    The channel is identified by the chain, port, and channel IDs at one of its ends

OPTIONS:
        --counterparty-key-name &lt;COUNTERPARTY_KEY_NAME&gt;
            use the given signing key for the counterparty chain (default: `counterparty_key_name`
            config)

        --key-name &lt;KEY_NAME&gt;
            use the given signing key for the specified chain (default: `key_name` config)

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel
        --port &lt;PORT_ID&gt;          Identifier of the port
</code></pre>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<ol>
<li>Without Hermes running, send 3 packets over a channel, here <code>channel-13</code>:</li>
</ol>
<pre><code>❯ hermes tx ft-transfer --receiver-chain ibc1 --sender-chain ibc0 --sender-port transfer --sender-channel channel-13 --amount 9999 --timeout-height-offset 1000 --number-msgs 3
2022-02-24T14:16:28.295526Z  INFO ThreadId(01) using default configuration from '/Users/coromac/.hermes/config.toml'
2022-02-24T14:16:28.330860Z  INFO ThreadId(15) send_tx{id=ibc0}: refresh: retrieved account sequence=61 number=1
2022-02-24T14:16:28.350022Z  INFO ThreadId(15) wait_for_block_commits: waiting for commit of tx hashes(s) AE4C3186778488E45670EB7303FA77E69B39F4E7C7494B05EC51E55136A373D6 id=ibc0
Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 86208,
            },
            packet: Packet {
                sequence: Sequence(
                    14,
                ),
                source_port: PortId(
                    &quot;transfer&quot;,
                ),
                source_channel: ChannelId(
                    &quot;channel-13&quot;,
                ),
                destination_port: PortId(
                    &quot;transfer&quot;,
                ),
                destination_channel: ChannelId(
                    &quot;channel-12&quot;,
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 86208,
            },
            packet: Packet {
                sequence: Sequence(
                    15,
                ),
                source_port: PortId(
                    &quot;transfer&quot;,
                ),
                source_channel: ChannelId(
                    &quot;channel-13&quot;,
                ),
                destination_port: PortId(
                    &quot;transfer&quot;,
                ),
                destination_channel: ChannelId(
                    &quot;channel-12&quot;,
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 86208,
            },
            packet: Packet {
                sequence: Sequence(
                    16,
                ),
                source_port: PortId(
                    &quot;transfer&quot;,
                ),
                source_channel: ChannelId(
                    &quot;channel-13&quot;,
                ),
                destination_port: PortId(
                    &quot;transfer&quot;,
                ),
                destination_channel: ChannelId(
                    &quot;channel-12&quot;,
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
]
</code></pre>
<ol start="2">
<li>Because the relayer is not running these packets won't be relayed,
as can be seen with the <code>query packet pending-sends</code> command:</li>
</ol>
<pre><code>❯ hermes query packet pending-sends --chain ibc1 --port transfer --channel channel-13
2022-02-24T14:21:28.874190Z  INFO ThreadId(01) using default configuration from '/Users/coromac/.hermes/config.toml'
Success: [
    14,
    15,
    16,
]
</code></pre>
<ol start="3">
<li>We can clear them manually using the <code>clear packets</code> command:</li>
</ol>
<pre><code>❯ hermes clear packets --chain ibc0 --port transfer --channel channel-13
2022-02-24T14:17:25.748422Z  INFO ThreadId(01) using default configuration from '/Users/coromac/.hermes/config.toml'
2022-02-24T14:17:25.799704Z  INFO ThreadId(01) PacketRecvCmd{src_chain=ibc0 src_port=transfer src_channel=channel-13 dst_chain=ibc1}: found unprocessed SendPacket events for [Sequence(14), Sequence(15), Sequence(16)] (first 10 shown here; total=3)
2022-02-24T14:17:25.827177Z  INFO ThreadId(01) PacketRecvCmd{src_chain=ibc0 src_port=transfer src_channel=channel-13 dst_chain=ibc1}: ready to fetch a scheduled op. data with batch of size 3 targeting Destination
2022-02-24T14:17:26.504798Z  INFO ThreadId(01) PacketRecvCmd{src_chain=ibc0 src_port=transfer src_channel=channel-13 dst_chain=ibc1}:relay{odata=E96CV_cA5P -&gt;Destination @0-86218; len=3}: assembled batch of 4 message(s)
2022-02-24T14:17:26.508873Z  INFO ThreadId(29) send_tx{id=ibc1}: refresh: retrieved account sequence=54 number=1
2022-02-24T14:17:26.561715Z  INFO ThreadId(29) wait_for_block_commits: waiting for commit of tx hashes(s) 07AA83524257105CC476063932A560893BE8F4E94C679BFD00F970FC248647E0 id=ibc1
2022-02-24T14:17:31.948950Z  INFO ThreadId(01) PacketRecvCmd{src_chain=ibc0 src_port=transfer src_channel=channel-13 dst_chain=ibc1}:relay{odata=E96CV_cA5P -&gt;Destination @0-86218; len=3}: [Sync-&gt;ibc1] result events:
    UpdateClientEv(h: 0-86215, cs_h: 07-tendermint-3(0-86219))
    WriteAcknowledgementEv(WriteAcknowledgement - h:0-86215, seq:14, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))
    WriteAcknowledgementEv(WriteAcknowledgement - h:0-86215, seq:15, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))
    WriteAcknowledgementEv(WriteAcknowledgement - h:0-86215, seq:16, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))


2022-02-24T14:17:31.949192Z  INFO ThreadId(01) PacketRecvCmd{src_chain=ibc0 src_port=transfer src_channel=channel-13 dst_chain=ibc1}:relay{odata=E96CV_cA5P -&gt;Destination @0-86218; len=3}: success
2022-02-24T14:17:31.989215Z  INFO ThreadId(01) PacketAckCmd{src_chain=ibc1 src_port=transfer src_channel=channel-12 dst_chain=ibc0}: found unprocessed WriteAcknowledgement events for [Sequence(14), Sequence(15), Sequence(16)] (first 10 shown here; total=3)
2022-02-24T14:17:32.013500Z  INFO ThreadId(01) PacketAckCmd{src_chain=ibc1 src_port=transfer src_channel=channel-12 dst_chain=ibc0}: ready to fetch a scheduled op. data with batch of size 3 targeting Destination
2022-02-24T14:17:33.211930Z  INFO ThreadId(01) PacketAckCmd{src_chain=ibc1 src_port=transfer src_channel=channel-12 dst_chain=ibc0}:relay{odata=L4fnSXkxL_ -&gt;Destination @0-86215; len=3}: assembled batch of 4 message(s)
2022-02-24T14:17:33.215803Z  INFO ThreadId(15) send_tx{id=ibc0}: refresh: retrieved account sequence=62 number=1
2022-02-24T14:17:33.245229Z  INFO ThreadId(15) wait_for_block_commits: waiting for commit of tx hashes(s) 62C69B1C46AF45182D5D99C6CB5EB301F8A402726772BA4EE067B18C68F2A4D6 id=ibc0
2022-02-24T14:17:37.465489Z  INFO ThreadId(01) PacketAckCmd{src_chain=ibc1 src_port=transfer src_channel=channel-12 dst_chain=ibc0}:relay{odata=L4fnSXkxL_ -&gt;Destination @0-86215; len=3}: [Sync-&gt;ibc0] result events:
    UpdateClientEv(h: 0-86221, cs_h: 07-tendermint-3(0-86216))
    AcknowledgePacketEv(h:0-86221, seq:14, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))
    AcknowledgePacketEv(h:0-86221, seq:15, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))
    AcknowledgePacketEv(h:0-86221, seq:16, path:channel-13/transfer-&gt;channel-12/transfer, toh:0-87203, tos:Timestamp(NoTimestamp)))


2022-02-24T14:17:37.465802Z  INFO ThreadId(01) PacketAckCmd{src_chain=ibc1 src_port=transfer src_channel=channel-12 dst_chain=ibc0}:relay{odata=L4fnSXkxL_ -&gt;Destination @0-86215; len=3}: success
Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 86215,
                },
                client_id: ClientId(
                    &quot;07-tendermint-3&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 0,
                    height: 86219,
                },
            },
            header: Some(
                Tendermint(
                     Header {...},
                ),
            ),
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 0,
                height: 86215,
            },
            packet: Packet {
                sequence: Sequence(
                    14,
                ),
                source_port: PortId(
                    &quot;transfer&quot;,
                ),
                source_channel: ChannelId(
                    &quot;channel-13&quot;,
                ),
                destination_port: PortId(
                    &quot;transfer&quot;,
                ),
                destination_channel: ChannelId(
                    &quot;channel-12&quot;,
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
            ack: [ ... ],
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 0,
                height: 86215,
            },
            packet: Packet {
                sequence: Sequence(
                    15,
                ),
                source_port: PortId(
                    &quot;transfer&quot;,
                ),
                source_channel: ChannelId(
                    &quot;channel-13&quot;,
                ),
                destination_port: PortId(
                    &quot;transfer&quot;,
                ),
                destination_channel: ChannelId(
                    &quot;channel-12&quot;,
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
            ack: [ ... ],
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 0,
                height: 86215,
            },
            packet: Packet {
                sequence: Sequence(
                    16,
                ),
                source_port: PortId(
                    &quot;transfer&quot;,
                ),
                source_channel: ChannelId(
                    &quot;channel-13&quot;,
                ),
                destination_port: PortId(
                    &quot;transfer&quot;,
                ),
                destination_channel: ChannelId(
                    &quot;channel-12&quot;,
                ),
                data: [ ... ],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
            ack: [ ... ],
        },
    ),
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 86221,
                },
                client_id: ClientId(
                    &quot;07-tendermint-3&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 0,
                    height: 86216,
                },
            },
            header: Some(
                Tendermint(
                     Header {...},
                ),
            ),
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 86221,
            },
            packet: Packet {
                sequence: Sequence(
                    14,
                ),
                source_port: PortId(
                    &quot;transfer&quot;,
                ),
                source_channel: ChannelId(
                    &quot;channel-13&quot;,
                ),
                destination_port: PortId(
                    &quot;transfer&quot;,
                ),
                destination_channel: ChannelId(
                    &quot;channel-12&quot;,
                ),
                data: [],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 86221,
            },
            packet: Packet {
                sequence: Sequence(
                    15,
                ),
                source_port: PortId(
                    &quot;transfer&quot;,
                ),
                source_channel: ChannelId(
                    &quot;channel-13&quot;,
                ),
                destination_port: PortId(
                    &quot;transfer&quot;,
                ),
                destination_channel: ChannelId(
                    &quot;channel-12&quot;,
                ),
                data: [],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 86221,
            },
            packet: Packet {
                sequence: Sequence(
                    16,
                ),
                source_port: PortId(
                    &quot;transfer&quot;,
                ),
                source_channel: ChannelId(
                    &quot;channel-13&quot;,
                ),
                destination_port: PortId(
                    &quot;transfer&quot;,
                ),
                destination_channel: ChannelId(
                    &quot;channel-12&quot;,
                ),
                data: [],
                timeout_height: Height {
                    revision: 0,
                    height: 87203,
                },
                timeout_timestamp: Timestamp {
                    time: None,
                },
            },
        },
    ),
]
</code></pre>
<ol start="4">
<li>The packets have now been successfully relayed:</li>
</ol>
<pre><code>❯ hermes query packet pending-sends --chain ibc1 --port transfer --channel channel-13
2022-02-24T14:21:28.874190Z  INFO ThreadId(01) using default configuration from '/Users/coromac/.hermes/config.toml'
Success: []
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relayer-listen-mode"><a class="header" href="#relayer-listen-mode">Relayer Listen Mode</a></h1>
<p>The relayer can be started in <code>listen</code> mode to display the events emitted by a given chain. <code>NewBlock</code> and <code>Tx</code> IBC events are shown.</p>
<pre><code class="language-shell">USAGE:
    hermes listen [OPTIONS] --chain &lt;CHAIN_ID&gt;

DESCRIPTION:
    Listen to and display IBC events emitted by a chain

OPTIONS:
        --events &lt;EVENT&gt;...    Add an event type to listen for, can be repeated. Listen for all
                               events by default (available: Tx, NewBlock)

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain to listen for events from
</code></pre>
<p><strong>Example</strong></p>
<p>Start the relayer in listen mode for all <code>ibc-0</code> events and observe the output:</p>
<pre><code class="language-shell">hermes listen --chain ibc-0
</code></pre>
<pre><code class="language-json">EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10914),
    events: [
        NewBlock(
            NewBlock {
                height: block::Height(10914),
            },
        ),
    ],
}
EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10915),
    events: [
        OpenInitConnection(
            OpenInit(
                Attributes {
                    height: block::Height(10915),
                    connection_id: Some(
                        ConnectionId(
                            &quot;connection-3&quot;,
                        ),
                    ),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    counterparty_connection_id: None,
                    counterparty_client_id: ClientId(
                        &quot;07-tendermint-5&quot;,
                    ),
                },
            ),
        ),
    ],

...

EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10919),
    events: [
        UpdateClient(
            UpdateClient(
                Attributes {
                    height: block::Height(10919),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    client_type: Tendermint,
                    consensus_height: Height {
                        revision: 1,
                        height: 10907,
                    },
                },
            ),
        ),
    ],
}

...

EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10924),
    events: [
        UpdateClient(
            UpdateClient(
                Attributes {
                    height: block::Height(10924),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    client_type: Tendermint,
                    consensus_height: Height {
                        revision: 1,
                        height: 10912,
                    },
                },
            ),
        ),
        OpenAckConnection(
            OpenAck(
                Attributes {
                    height: block::Height(10924),
                    connection_id: Some(
                        ConnectionId(
                            &quot;connection-3&quot;,
                        ),
                    ),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    counterparty_connection_id: Some(
                        ConnectionId(
                            &quot;connection-5&quot;,
                        ),
                    ),
                    counterparty_client_id: ClientId(
                        &quot;07-tendermint-5&quot;,
                    ),
                },
            ),
        ),
    ],
}
</code></pre>
<h2 id="filter-events"><a class="header" href="#filter-events">Filter events</a></h2>
<p>The <code>listen</code> command accepts an <code>--event</code> flag to specify which event types to listen for.</p>
<p>At the moment, two event types are available:</p>
<ul>
<li><code>NewBlock</code> </li>
<li><code>Tx</code></li>
</ul>
<p>The <code>--event</code> flag can be repeated to specify more than one event type.</p>
<ul>
<li>To listen for only <code>NewBlock</code> events on <code>ibc-0</code>, invoke <code>hermes listen --chain ibc-0 --events NewBlock</code></li>
<li>To listen for only <code>Tx</code> events on <code>ibc-0</code>, invoke <code>hermes listen --chain ibc-0 --events Tx</code></li>
<li>To listen for both <code>NewBlock</code> and <code>Tx</code> events on <code>ibc-0</code>, invoke <code>hermes listen --chain ibc-0 --events NewBlock Tx</code></li>
</ul>
<p>If the <code>--event</code> flag is omitted, the relayer will subscribe to all event types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-upgrade"><a class="header" href="#client-upgrade">Client Upgrade</a></h1>
<h2 id="client-upgrade-command"><a class="header" href="#client-upgrade-command">Client Upgrade Command</a></h2>
<p>Use the <code>upgrade client</code> command to upgrade a client after a chain upgrade.</p>
<pre><code class="language-shell">USAGE:
    hermes upgrade client --host-chain &lt;HOST_CHAIN_ID&gt; --client &lt;CLIENT_ID&gt; --upgrade-height &lt;REFERENCE_UPGRADE_HEIGHT&gt;

DESCRIPTION:
    Upgrade an IBC client

REQUIRED:
        --client &lt;CLIENT_ID&gt;
            Identifier of the client to be upgraded

        --host-chain &lt;HOST_CHAIN_ID&gt;
            Identifier of the chain that hosts the client

        --upgrade-height &lt;REFERENCE_UPGRADE_HEIGHT&gt;
            The height at which the reference chain halts for the client upgrade
</code></pre>
<p><strong>Example</strong></p>
<p>Here is <a href="commands/upgrade/./test.html">an example</a> of a chain upgrade proposal submission and client upgrade.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-client-upgrade"><a class="header" href="#testing-client-upgrade">Testing Client Upgrade</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>gaiad <code>(v7.0.*)</code>, for example:</li>
</ul>
<pre><code class="language-shell">gaiad version --log_level error --long | head -n4
</code></pre>
<h2 id="testing-procedure"><a class="header" href="#testing-procedure">Testing procedure</a></h2>
<h3 id="setup-using-gaia-manager"><a class="header" href="#setup-using-gaia-manager">Setup using Gaia manager</a></h3>
<blockquote>
<p>Note: The <code>gm.toml</code> file that we're using here looks like this:</p>
</blockquote>
<pre><code>[global]
  add_to_hermes = true
  auto_maintain_config = true
  extra_wallets = 2
  gaiad_binary = &quot;$GOPATH/bin/gaiad&quot;
  hdpath = &quot;&quot;
  home_dir = &quot;$HOME/.gm&quot;
  ports_start_at = 27040
  validator_mnemonic = &quot;&quot;
  wallet_mnemonic = &quot;&quot;

  [global.hermes]
    binary = &quot;&lt;path/to/hermes&gt;&quot;
    config = &quot;$HOME/.hermes/config.toml&quot;
    log_level = &quot;info&quot;
    telemetry_enabled = true
    telemetry_host = &quot;127.0.0.1&quot;
    telemetry_port = 3001

[ibc-0]
  ports_start_at = 27000

[ibc-1]
  ports_start_at = 27010
</code></pre>
<ul>
<li>Run the command <code>gm start</code></li>
<li>Go to the file <code>$HOME/.gm/ibc-0/config/genesis.json</code> and change <code>max_deposit_period</code> and <code>voting_period</code> to a lower value, such as 120s</li>
<li>Run the commands: <code>gm reset</code>, <code>gm hermes config</code> and <code>gm hermes keys</code></li>
</ul>
<h3 id="test-upgrading-chain-and-client"><a class="header" href="#test-upgrading-chain-and-client">Test upgrading chain and client</a></h3>
<ol>
<li>
<p>Create one client on <code>ibc-1</code> for <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes create client --host-chain ibc-1 --reference-chain ibc-0
</code></pre>
<pre><code class="language-json">Success: CreateClient(
   CreateClient(
       Attributes {
           height: Height { revision: 1, height: 9 },
           client_id: ClientId(
               &quot;07-tendermint-0&quot;,
           ),
           client_type: Tendermint,
           consensus_height: Height { revision: 0, height: 18 },
       },
   ),
)
</code></pre>
</li>
<li>
<p>Create and submit an upgrade plan for chain <code>ibc-0</code>:</p>
<p>Use the hermes test command to make an upgrade proposal. In the example below a software upgrade proposal is made for <code>ibc-0</code>, for the height <code>300</code> blocks from latest height. <code>10000000stake</code> is deposited.
The proposal includes the upgraded client state constructed from the state of <code>07-tendermint-0</code> client on <code>ibc-1</code> that was created in the previous step.</p>
<pre><code class="language-shell">hermes tx upgrade-chain --receiver-chain ibc-0 --sender-chain ibc-1 --sender-client 07-tendermint-0 --amount 10000000 --height-offset 60
</code></pre>
<pre><code class="language-text">Success: transaction::Hash(CE98D8D98091BA8016BD852D18056E54C4CB3C4525E7F40DD3C40B4FD0F2482B)
</code></pre>
</li>
<li>
<p>Verify that the proposal was accepted by querying the upgrade plan to check that it was submitted correctly.</p>
<blockquote>
<p>Note: You can find the RPC port used to query the local node by running
<code>gm ports</code> in order to see a list of the ports being used.</p>
</blockquote>
<pre><code class="language-shell">gaiad --node tcp://localhost:27000 query gov proposal 1 --home $HOME/.gm/ibc-0/
</code></pre>
<p>If successful, you should see output like this. Note that the status of the proposal near the bottom of the output should be
<code>PROPOSAL_STATUS_VOTING_PERIOD</code> indicating that the voting period is still ongoing.</p>
<pre><code class="language-text">content:
  '@type': /ibc.core.client.v1.UpgradeProposal
  description: upgrade the chain software and unbonding period
  plan:
    height: &quot;65&quot;
    info: &quot;&quot;
    name: plan
    time: &quot;0001-01-01T00:00:00Z&quot;
    upgraded_client_state: null
  title: proposal 0
  upgraded_client_state:
    '@type': /ibc.lightclients.tendermint.v1.ClientState
    allow_update_after_expiry: false
    allow_update_after_misbehaviour: false
    chain_id: ibc-0
    frozen_height:
      revision_height: &quot;0&quot;
      revision_number: &quot;0&quot;
    latest_height:
      revision_height: &quot;66&quot;
      revision_number: &quot;0&quot;
    max_clock_drift: 0s
    proof_specs:
    - inner_spec:
        child_order:
        - 0
        - 1
        child_size: 33
        empty_child: null
        hash: SHA256
        max_prefix_length: 12
        min_prefix_length: 4
      leaf_spec:
        hash: SHA256
        length: VAR_PROTO
        prefix: AA==
        prehash_key: NO_HASH
        prehash_value: SHA256
      max_depth: 0
      min_depth: 0
    - inner_spec:
        child_order:
        - 0
        - 1
        child_size: 32
        empty_child: null
        hash: SHA256
        max_prefix_length: 1
        min_prefix_length: 1
      leaf_spec:
        hash: SHA256
        length: VAR_PROTO
        prefix: AA==
        prehash_key: NO_HASH
        prehash_value: SHA256
      max_depth: 0
      min_depth: 0
    trust_level:
      denominator: &quot;0&quot;
      numerator: &quot;0&quot;
    trusting_period: 0s
    unbonding_period: 1814400s
    upgrade_path:
    - upgrade
    - upgradedIBCState
deposit_end_time: &quot;2022-07-06T15:14:38.993051Z&quot;
final_tally_result:
  abstain: &quot;0&quot;
  &quot;no&quot;: &quot;0&quot;
  no_with_veto: &quot;0&quot;
  &quot;yes&quot;: &quot;0&quot;
proposal_id: &quot;1&quot;
status: PROPOSAL_STATUS_VOTING_PERIOD
submit_time: &quot;2022-07-06T15:12:38.993051Z&quot;
total_deposit:
- amount: &quot;10000000&quot;
  denom: stake
voting_end_time: &quot;2022-07-06T15:14:38.993051Z&quot;
voting_start_time: &quot;2022-07-06T15:12:38.993051Z&quot;
</code></pre>
</li>
<li>
<p>Vote on the proposal</p>
<p>The parameter <code>1</code> should match the <code>proposal_id:</code> from the upgrade proposal submitted at step 3.
This command must be issued while the proposal status is <code>PROPOSAL_STATUS_VOTING_PERIOD</code>. Confirm transaction when prompted.</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:27000 tx gov vote 1 yes --home $HOME/.gm/ibc-0/data/ --keyring-backend test --keyring-dir $HOME/.gm/ibc-0/ --chain-id ibc-0 --from validator
</code></pre>
<pre><code class="language-text">confirm transaction before signing and broadcasting [y/N]: y

txhash: 50CC1C39FBB14F99580A916ADE7F02883FFCC35D7862153F16BE86138151E17C
</code></pre>
</li>
<li>
<p>Test the <code>upgrade client</code> CLI</p>
<p>The following command waits for the reference chain <code>ibc-0</code> to halt and then performs the upgrade for client <code>07-tendermint-0</code> on <code>ibc-1</code>. It outputs two events, one for the updated client state,
and another for the upgraded state.
The <code>--upgrade-height 65</code> value is taken from the <code>height</code> in the upgrade plan output.</p>
<pre><code class="language-shell">hermes upgrade client --host-chain ibc-1 --client 07-tendermint-0 --upgrade-height 65
</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        h: 1-68, cs_h: 07-tendermint-0(0-65),
    ),
    UpgradeClient(
        UpgradeClient(
            Attributes {
                height: Height {
                    revision: 1,
                    height: 68,
                },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 0,
                    height: 66,
                },
            },
        ),
    ),
]
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="misbehaviour"><a class="header" href="#misbehaviour">Misbehaviour</a></h1>
<h2 id="table-of-contents-7"><a class="header" href="#table-of-contents-7">Table of Contents</a></h2>
<ul>
<li><a href="commands/misbehaviour/index.html#monitoring-misbehaviour-and-evidence-submission">Monitoring Misbehaviour and Evidence Submission</a></li>
</ul>
<h2 id="monitoring-misbehaviour-and-evidence-submission"><a class="header" href="#monitoring-misbehaviour-and-evidence-submission">Monitoring Misbehaviour and Evidence Submission</a></h2>
<p>Use the <code>mishbehaviour</code> command to monitor the updates for a given client, detect certain types of misbehaviour and
submit evidence to the chain. If the evidence passes the on-chain validation, the client is frozen. Further packets
cannot be relayed using the frozen client.</p>
<pre><code class="language-shell">USAGE:
    hermes misbehaviour --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

DESCRIPTION:
    Listen to client update IBC events and handles misbehaviour

REQUIRED:
        --chain &lt;CHAIN_ID&gt;      Identifier of the chain where client updates are monitored for
                                misbehaviour
        --client &lt;CLIENT_ID&gt;    Identifier of the client to be monitored for misbehaviour
</code></pre>
<p>The misbehaviour monitor starts by analyzing all headers used in prior client updates.
Once finished it registers for update client events and checks any new headers for misbehaviour.
If it detects evidence of misbehaviour, it submits a transaction with the evidence to the chain.
If the chain validates the transaction then the monitor exits.</p>
<blockquote>
<p>This is an experimental feature.</p>
</blockquote>
<p>The following types of misbehaviour are handled:</p>
<ol>
<li>
<p><strong>Fork</strong></p>
<p>Assumes at least one consensus state before the fork point exists.
Let existing consensus states on chain B be: <code>[Sn,.., Sf, Sf-1, S0]</code> with <code>Sf-1</code> being
the most recent state before the fork.
Chain A is queried for a header <code>Hf'</code> at <code>Sf.height</code> and if it is different than the <code>Hf</code>
in the event for the client update (the one that has generated <code>Sf</code> on chain), then the two
headers are included in the evidence and submitted.
Note that in this case the headers are different but have the same height.</p>
</li>
<li>
<p><strong>BFT time violation for an unavailable header</strong></p>
<p>Some header with a height that is higher than the latest
height on chain <code>A</code> has been accepted and a consensus state was created on <code>B</code>. Note that this implies
that the timestamp of this header must be within the <code>clock_drift</code> of the client.
Assume the client on <code>B</code> has been updated with <code>h2</code>(not present on/ produced by chain <code>A</code>)
and it has a timestamp of <code>t2</code> that is at most <code>clock_drift</code> in the future.
Then the latest header from <code>A</code> is fetched, let it be <code>h1</code>, with a timestamp of <code>t1</code>.
If <code>t1 &gt;= t2</code> then evidence of misbehavior is submitted to A.</p>
</li>
</ol>
<p><strong>Example</strong></p>
<p>The <code>hermes misbehaviour</code> outputs an error message displaying <code>MISBEHAVIOUR DETECTED</code>:</p>
<pre><code class="language-shell">hermes misbehaviour --chain ibc-0 --client 07-tendermint-0
</code></pre>
<pre><code class="language-json">Apr 13 20:04:03.347  INFO ibc_relayer::foreign_client: checking misbehaviour for consensus state heights [Height { revision: 1, height: 195 }, Height { revision: 1, height: 85 }, Height { revision: 1, height: 28 }]
Apr 13 20:04:04.425 ERROR ibc_relayer::foreign_client: MISBEHAVIOUR DETECTED ClientId(&quot;07-tendermint-0&quot;) h1: Height { revision: 1, height: 195 }-Height { revision: 1, height: 85 } h2: Height { revision: 1, height: 195 }-Height { revision: 1, height: 85 }, sending evidence
Apr 13 20:04:05.070  INFO ibc_relayer_cli::commands::misbehaviour: evidence submission result [ClientMisbehaviour(ClientMisbehaviour(Attributes { height: Height { revision: 0, height: 1521 }, client_id: ClientId(&quot;07-tendermint-0&quot;), client_type: Tendermint, consensus_height: Height { revision: 1, height: 195 } }))]

Success: Some(
    ClientMisbehaviour(
        ClientMisbehaviour(
            Attributes {
                height: Height {
                    revision: 0,
                    height: 1521,
                },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 195,
                },
            },
        ),
    ),
)
</code></pre>
<p>Querying client state from this point will show the client is in frozen state, with <code>frozen_height</code> indicating the height at which the client was frozen:</p>
<pre><code class="language-shell">hermes query client state --chain ibc-0 --client 07-tendermint-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;result&quot;: {
    &quot;allow_update_after_expiry&quot;: true,
    &quot;allow_update_after_misbehaviour&quot;: true,
    &quot;chain_id&quot;: &quot;ibc-1&quot;,
    &quot;frozen_height&quot;: {
      &quot;revision_height&quot;: 16,
      &quot;revision_number&quot;: 1
    },
    &quot;latest_height&quot;: {
      &quot;revision_height&quot;: 16,
      &quot;revision_number&quot;: 1
    },
    &quot;max_clock_drift&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 3
    },
    &quot;trust_level&quot;: {
      &quot;denominator&quot;: &quot;3&quot;,
      &quot;numerator&quot;: &quot;1&quot;
    },
    &quot;trusting_period&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 1209600
    },
    &quot;unbonding_period&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 1814400
    },
    &quot;upgrade_path&quot;: [
      &quot;upgrade&quot;,
      &quot;upgradedIBCState&quot;
    ]
  },
  &quot;status&quot;: &quot;success&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Hermes supports querying for different objects that exist on a configured chain.</p>
<p>The <code>query</code> command provides the following sub-commands:</p>
<div class="table-wrapper"><table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>client</code></td><td><a href="commands/queries/./client.html">Query information about clients</a></td></tr>
<tr><td><code>clients</code></td><td><a href="commands/queries/./client.html">Query all clients</a></td></tr>
<tr><td><code>connection</code></td><td><a href="commands/queries/./connection.html">Query information about connections</a></td></tr>
<tr><td><code>connections</code></td><td><a href="commands/queries/./connection.html">Query the identifiers of all connections on a chain</a></td></tr>
<tr><td><code>channel</code></td><td><a href="commands/queries/./channel.html">Query information about channels</a></td></tr>
<tr><td><code>channels</code></td><td><a href="commands/queries/./channel.html">Query the identifiers of all channels on a given chain</a></td></tr>
<tr><td><code>packet</code></td><td><a href="commands/queries/./packet.html">Query information about packets</a></td></tr>
<tr><td><code>transfer</code></td><td><a href="commands/queries/./transfer.html">Query information about token transfers</a></td></tr>
<tr><td><code>tx</code></td><td><a href="commands/queries/./tx.html">Query information about transactions</a></td></tr>
</tbody></table>
</div>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code>USAGE:
    hermes query &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query objects from the chain

SUBCOMMANDS:
    client         Query information about clients
    clients        Query clients
    connection     Query information about connections
    connections    Query the identifiers of all connections on a chain
    channel        Query information about channels
    channels       Query the identifiers of all channels on a given chain
    packet         Query information about packets
    transfer       Query information about token transfers
    tx             Query information about transactions
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents-8"><a class="header" href="#table-of-contents-8">Table of Contents</a></h1>
<ul>
<li><a href="commands/queries/client.html#query-clients">Query Clients</a></li>
<li><a href="commands/queries/client.html#query-client-data">Query Client Data</a>
<ul>
<li><a href="commands/queries/client.html#query-the-client-state">Query the client state</a></li>
<li><a href="commands/queries/client.html#query-the-client-consensus-state">Query the client consensus state</a></li>
<li><a href="commands/queries/client.html#query-the-identifiers-of-all-connections-associated-with-a-given-client">Query the identifiers of all connections associated with a given client</a></li>
<li><a href="commands/queries/client.html#query-for-the-header-used-in-a-client-update-at-a-certain-height">Query for the header used in a client update at a certain height</a></li>
</ul>
</li>
</ul>
<h1 id="query-clients"><a class="header" href="#query-clients">Query Clients</a></h1>
<p>Use the <code>query clients</code> command to query the identifiers of all clients on a given chain, called
the <em>host</em> chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query clients [OPTIONS] --host-chain &lt;HOST_CHAIN_ID&gt;

DESCRIPTION:
    Query the identifiers of all clients on a chain

OPTIONS:
        --omit-chain-ids
            Omit printing the reference (or target) chain for each client

        --reference-chain &lt;REFERENCE_CHAIN_ID&gt;
            Filter for clients which target a specific chain id (implies '--omit-chain-ids')

REQUIRED:
        --host-chain &lt;HOST_CHAIN_ID&gt;    Identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all clients on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query clients --host-chain ibc-1
</code></pre>
<pre><code class="language-json">Success: [
    ClientChain {
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        chain_id: ChainId {
            id: &quot;ibc-0&quot;,
            version: 0,
        },
    },
    ClientChain {
        client_id: ClientId(
            &quot;07-tendermint-1&quot;,
        ),
        chain_id: ChainId {
            id: &quot;ibc-2&quot;,
            version: 2,
        },
    },
]
</code></pre>
<p>Query all clients on <code>ibc-1</code> having <code>ibc-2</code> as their reference chain:</p>
<pre><code class="language-shell">hermes query clients --host-chain ibc-1 --reference-chain ibc-2
</code></pre>
<pre><code class="language-json">Success: [
    ClientId(
        &quot;07-tendermint-1&quot;,
    ),
]
</code></pre>
<h1 id="query-client-data"><a class="header" href="#query-client-data">Query Client Data</a></h1>
<p>Use the <code>query client</code> command to query the information about a specific client.</p>
<pre><code class="language-shell">USAGE:
    hermes query client &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about clients

SUBCOMMANDS:
    connections    Query the client connections
    consensus      Query the client consensus state
    header         Query for the header used in a client update at a certain height
    state          Query the client full state
</code></pre>
<h2 id="query-the-client-state"><a class="header" href="#query-the-client-state">Query the client state</a></h2>
<p>Use the <code>query client state</code> command to query the client state of a client:</p>
<pre><code class="language-shell">USAGE:
    hermes query client state [OPTIONS] --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

DESCRIPTION:
    Query the client state

OPTIONS:
        --height &lt;HEIGHT&gt;    The chain height context for the query

REQUIRED:
        --chain &lt;CHAIN_ID&gt;      Identifier of the chain to query
        --client &lt;CLIENT_ID&gt;    Identifier of the client to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the state of client <code>07-tendermint-2</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query client state --chain ibc-1 --client 07-tendermint-1
</code></pre>
<pre><code class="language-json">Success: ClientState {
    chain_id: ChainId {
        id: &quot;ibc-2&quot;,
        version: 2,
    },
    trust_level: TrustThresholdFraction {
        numerator: 1,
        denominator: 3,
    },
    trusting_period: 1209600s,
    unbonding_period: 1814400s,
    max_clock_drift: 3s,
    frozen_height: Height {
        revision: 0,
        height: 0,
    },
    latest_height: Height {
        revision: 2,
        height: 3069,
    },
    upgrade_path: [
        &quot;upgrade&quot;,
        &quot;upgradedIBCState&quot;,
    ],
    allow_update_after_expiry: true,
    allow_update_after_misbehaviour: true,
}
</code></pre>
<h2 id="query-the-client-consensus-state"><a class="header" href="#query-the-client-consensus-state">Query the client consensus state</a></h2>
<p>Use the <code>query client consensus</code> command to query the consensus states of a given client, or the state at a specified height:</p>
<pre><code class="language-shell">USAGE:
    hermes query client consensus [OPTIONS] --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

DESCRIPTION:
    Query client consensus state

OPTIONS:
        --consensus-height &lt;CONSENSUS_HEIGHT&gt;
            Height of the client's consensus state to query

        --height &lt;HEIGHT&gt;
            The chain height context to be used, applicable only to a specific height

        --heights-only
            Show only consensus heights

REQUIRED:
        --chain &lt;CHAIN_ID&gt;      Identifier of the chain to query
        --client &lt;CLIENT_ID&gt;    Identifier of the client to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the states of client <code>07-tendermint-0</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client consensus --chain ibc-0 --client 07-tendermint-0 --heights-only
</code></pre>
<pre><code class="language-json">Success: [
    Height {
        revision: 1,
        height: 3049,
    },
    Height {
        revision: 1,
        height: 2888,
    },
    Height {
        revision: 1,
        height: 2736,
    },
    Height {
        revision: 1,
        height: 2729,
    },
    Height {
        revision: 1,
        height: 2724,
    },
    Height {
        revision: 1,
        height: 2717,
    },
]
</code></pre>
<p>Query <code>ibc-0</code> at height <code>2800</code> for the consensus state for height <code>2724</code>:</p>
<pre><code class="language-shell">hermes query client consensus --chain ibc-0 --client 07-tendermint-0 --consensus-height 2724 --height 2800
</code></pre>
<pre><code class="language-json">Success: ConsensusState {
    timestamp: Time(
        2021-04-13T14:11:20.969154Z
    ),
    root: CommitmentRoot(
        &quot;371DD19003221B60162D42C78FD86ABF95A572F3D9497084584B75F97B05B70C&quot;
    ),
    next_validators_hash: Hash::Sha256(
        740950668B6705A136D041914FC219045B1D0AD1C6A284C626BF5116005A98A7
    ),
}
</code></pre>
<h2 id="query-the-identifiers-of-all-connections-associated-with-a-given-client"><a class="header" href="#query-the-identifiers-of-all-connections-associated-with-a-given-client">Query the identifiers of all connections associated with a given client</a></h2>
<p>Use the <code>query client connections</code> command to query the connections associated with a given client:</p>
<pre><code class="language-shell">USAGE:
    hermes query client connections [OPTIONS] --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt;

DESCRIPTION:
    Query client connections

OPTIONS:
        --height &lt;HEIGHT&gt;    The chain height which this query should reflect

REQUIRED:
        --chain &lt;CHAIN_ID&gt;      Identifier of the chain to query
        --client &lt;CLIENT_ID&gt;    Identifier of the client to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the connections of client <code>07-tendermint-0</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client connections --chain ibc-0 --client 07-tendermint-0
</code></pre>
<pre><code class="language-json">Success: [
    ConnectionId(&quot;connection-0&quot;),
    ConnectionId(&quot;connection-1&quot;),
]
</code></pre>
<h2 id="query-for-the-header-used-in-a-client-update-at-a-certain-height"><a class="header" href="#query-for-the-header-used-in-a-client-update-at-a-certain-height">Query for the header used in a client update at a certain height</a></h2>
<pre><code>USAGE:
    hermes query client header [OPTIONS] --chain &lt;CHAIN_ID&gt; --client &lt;CLIENT_ID&gt; --consensus-height &lt;CONSENSUS_HEIGHT&gt;

DESCRIPTION:
    Query for the header used in a client update at a certain height

OPTIONS:
        --height &lt;HEIGHT&gt;    The chain height context for the query. Leave unspecified for latest
                             height.

REQUIRED:
        --chain &lt;CHAIN_ID&gt;                       Identifier of the chain to query
        --client &lt;CLIENT_ID&gt;                     Identifier of the client to query
        --consensus-height &lt;CONSENSUS_HEIGHT&gt;    Height of header to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query for the header used in the <code>07-tendermint-0</code> client update at height 2724 on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client header --chain ibc-0 --client 07-tendermint-0 --consensus-height 2724
</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 0,
                },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 2724,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents-9"><a class="header" href="#table-of-contents-9">Table of Contents</a></h1>
<ul>
<li><a href="commands/queries/connection.html#query-connections">Query Connections</a></li>
<li><a href="commands/queries/connection.html#query-connection-data">Query Connection Data</a>
<ul>
<li><a href="commands/queries/connection.html#query-the-connection-end-data">Query the connection end data</a></li>
<li><a href="commands/queries/connection.html#query-the-identifiers-of-all-channels-associated-with-a-given-connection">Query the identifiers of all channels associated with a given connection</a></li>
</ul>
</li>
</ul>
<h1 id="query-connections"><a class="header" href="#query-connections">Query Connections</a></h1>
<p>Use the <code>query connections</code> command to query the identifiers of all connections on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query connections --chain &lt;CHAIN_ID&gt;

DESCRIPTION:
    Query the identifiers of all connections on a chain

OPTIONS:
        --counterparty-chain &lt;COUNTERPARTY_CHAIN_ID&gt;
            Filter the query response by the counterparty chain

        --verbose
            Enable verbose output, displaying the client for each connection in the response

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all connections on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connections --chain ibc-1
</code></pre>
<pre><code class="language-json">Success: [
    ConnectionId(
        &quot;connection-0&quot;,
    ),
    ConnectionId(
        &quot;connection-1&quot;,
    ),
]
</code></pre>
<h1 id="query-connection-data"><a class="header" href="#query-connection-data">Query Connection Data</a></h1>
<p>Use the <code>query connection</code> commands to query a specific connection.</p>
<pre><code class="language-shell">USAGE:
    hermes query connection &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about connection(s)

SUBCOMMANDS:
    end        query connection end
    channels   query connection channels
</code></pre>
<h2 id="query-the-connection-end-data"><a class="header" href="#query-the-connection-end-data">Query the connection end data</a></h2>
<p>Use the <code>query connection end</code> command to query the connection end:</p>
<pre><code class="language-shell">USAGE:
    hermes query connection end [OPTIONS] --chain &lt;CHAIN_ID&gt; --connection &lt;CONNECTION_ID&gt;

DESCRIPTION:
    Query connection end

OPTIONS:
        --height &lt;HEIGHT&gt;    Height of the state to query. Leave unspecified for latest height.

REQUIRED:
        --chain &lt;CHAIN_ID&gt;              Identifier of the chain to query
        --connection &lt;CONNECTION_ID&gt;    Identifier of the connection to query [aliases: conn]
</code></pre>
<p><strong>Example</strong></p>
<p>Query the connection end of connection <code>connection-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connection end --chain ibc-1 --connection connection-1
</code></pre>
<pre><code class="language-json">Success: ConnectionEnd {
    state: Open,
    client_id: ClientId(
        &quot;07-tendermint-1&quot;,
    ),
    counterparty: Counterparty {
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: Some(
            ConnectionId(
                &quot;connection-0&quot;,
            ),
        ),
        prefix: ibc,
    },
    versions: [
        Version {
            identifier: &quot;1&quot;,
            features: [
                &quot;ORDER_ORDERED&quot;,
                &quot;ORDER_UNORDERED&quot;,
            ],
        },
    ],
    delay_period: 0s,
}
</code></pre>
<h2 id="query-the-identifiers-of-all-channels-associated-with-a-given-connection"><a class="header" href="#query-the-identifiers-of-all-channels-associated-with-a-given-connection">Query the identifiers of all channels associated with a given connection</a></h2>
<p>Use the <code>query connection channels</code> command to query the identifiers of the channels associated with a given connection:</p>
<pre><code class="language-shell">USAGE:
    hermes query connection channels --chain &lt;CHAIN_ID&gt; --connection &lt;CONNECTION_ID&gt;

DESCRIPTION:
    Query connection channels

REQUIRED:
        --chain &lt;CHAIN_ID&gt;              Identifier of the chain to query
        --connection &lt;CONNECTION_ID&gt;    Identifier of the connection to query [aliases: conn]
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channels associated with connection <code>connection-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connection channels --chain ibc-1 --connection connection-1
</code></pre>
<pre><code class="language-json">Success: [
    PortChannelId {
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
    },
    PortChannelId {
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
    },
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents-10"><a class="header" href="#table-of-contents-10">Table of Contents</a></h1>
<ul>
<li><a href="commands/queries/channel.html#query-channels">Query Channels</a></li>
<li><a href="commands/queries/channel.html#query-channel-data">Query Channel Data</a>
<ul>
<li><a href="commands/queries/channel.html#query-the-channel-end-data">Query the channel end data</a></li>
<li><a href="commands/queries/channel.html#query-the-channel-data-for-both-ends-of-a-channel">Query the channel data for both ends of a channel</a></li>
<li><a href="commands/queries/channel.html#query-the-channel-client-state">Query the channel client state</a></li>
</ul>
</li>
</ul>
<h1 id="query-channels"><a class="header" href="#query-channels">Query Channels</a></h1>
<p>Use the <code>query channels</code> command to query the identifiers of all channels on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query channels [OPTIONS] --chain &lt;CHAIN_ID&gt;

DESCRIPTION:
    Query the identifiers of all channels on a given chain

OPTIONS:
        --counterparty-chain &lt;COUNTERPARTY_CHAIN_ID&gt;
            Filter the query response by the this counterparty chain

        --verbose
            Enable verbose output, displaying the client and connection ids for each channel in the
            response

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all channels on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query channels --chain ibc-1
</code></pre>
<pre><code class="language-json">Success: [
    PortChannelId {
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
    },
    PortChannelId {
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
    },
]
</code></pre>
<h1 id="query-channel-data"><a class="header" href="#query-channel-data">Query Channel Data</a></h1>
<p>Use the <code>query channel</code> commands to query the information about a specific channel.</p>
<pre><code class="language-shell">USAGE:
    hermes query channel &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about channels

SUBCOMMANDS:
    client     Query channel's client state
    end        Query channel end
    ends       Query channel ends and underlying connection and client objects
</code></pre>
<h2 id="query-the-channel-end-data"><a class="header" href="#query-the-channel-end-data">Query the channel end data</a></h2>
<p>Use the <code>query channel end</code> command to query the channel end:</p>
<pre><code class="language-shell">USAGE:
    hermes query channel end [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

DESCRIPTION:
    Query channel end

OPTIONS:
        --height &lt;HEIGHT&gt;    Height of the state to query

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channel end of channel <code>channel-1</code> on port <code>transfer</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query channel end --chain ibc-1 --port transfer --channel channel-1
</code></pre>
<pre><code class="language-json">Success: ChannelEnd {
    state: Open,
    ordering: Unordered,
    remote: Counterparty {
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: Some(
            ChannelId(
                &quot;channel-0&quot;,
            ),
        ),
    },
    connection_hops: [
        ConnectionId(
            &quot;connection-1&quot;,
        ),
    ],
    version: &quot;ics20-1&quot;,
}
</code></pre>
<h2 id="query-the-channel-data-for-both-ends-of-a-channel"><a class="header" href="#query-the-channel-data-for-both-ends-of-a-channel">Query the channel data for both ends of a channel</a></h2>
<p>Use the <code>query channel ends</code> command to obtain both ends of a channel:</p>
<pre><code class="language-shell">USAGE:
    hermes query channel ends [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

DESCRIPTION:
    Query channel ends and underlying connection and client objects

OPTIONS:
        --height &lt;HEIGHT&gt;    Height of the state to query
        --verbose            Enable verbose output, displaying all details of channels, connections
                             &amp; clients

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channel end of channel <code>channel-1</code> on port <code>transfer</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query channel ends --chain ibc-0 --port transfer --channel channel-1
</code></pre>
<pre><code class="language-json">Success: ChannelEndsSummary {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    client_id: ClientId(
        &quot;07-tendermint-1&quot;,
    ),
    connection_id: ConnectionId(
        &quot;connection-1&quot;,
    ),
    channel_id: ChannelId(
        &quot;channel-1&quot;,
    ),
    port_id: PortId(
        &quot;transfer&quot;,
    ),
    counterparty_chain_id: ChainId {
        id: &quot;ibc-2&quot;,
        version: 2,
    },
    counterparty_client_id: ClientId(
        &quot;07-tendermint-1&quot;,
    ),
    counterparty_connection_id: ConnectionId(
        &quot;connection-1&quot;,
    ),
    counterparty_channel_id: ChannelId(
        &quot;channel-1&quot;,
    ),
    counterparty_port_id: PortId(
        &quot;transfer&quot;,
    ),
}
</code></pre>
<p>Passing the <code>--verbose</code> flag will additionally print all the details of the
channel, connection, and client on both ends.</p>
<h2 id="query-the-channel-client-state"><a class="header" href="#query-the-channel-client-state">Query the channel client state</a></h2>
<p>Use the <code>query channel client</code> command to obtain the channel's client state:</p>
<pre><code class="language-shell">USAGE:
    hermes query channel client --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

DESCRIPTION:
    Query channel's client state

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
</code></pre>
<p>If the command is successful a message with the following format will be displayed:</p>
<pre><code>Success: Some(
    IdentifiedAnyClientState {
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        client_state: Tendermint(
            ClientState {
                chain_id: ChainId {
                    id: &quot;network2&quot;,
                    version: 0,
                },
                trust_level: TrustThreshold {
                    numerator: 1,
                    denominator: 3,
                },
                trusting_period: 1209600s,
                unbonding_period: 1814400s,
                max_clock_drift: 40s,
                latest_height: Height {
                    revision: 0,
                    height: 2775,
                },
                proof_specs: ProofSpecs(
                    [
                        ProofSpec(
                            ProofSpec {
                                leaf_spec: Some(
                                    LeafOp {
                                        hash: Sha256,
                                        prehash_key: NoHash,
                                        prehash_value: Sha256,
                                        length: VarProto,
                                        prefix: [
                                            0,
                                        ],
                                    },
                                ),
                                inner_spec: Some(
                                    InnerSpec {
                                        child_order: [
                                            0,
                                            1,
                                        ],
                                        child_size: 33,
                                        min_prefix_length: 4,
                                        max_prefix_length: 12,
                                        empty_child: [],
                                        hash: Sha256,
                                    },
                                ),
                                max_depth: 0,
                                min_depth: 0,
                            },
                        ),
                        ProofSpec(
                            ProofSpec {
                                leaf_spec: Some(
                                    LeafOp {
                                        hash: Sha256,
                                        prehash_key: NoHash,
                                        prehash_value: Sha256,
                                        length: VarProto,
                                        prefix: [
                                            0,
                                        ],
                                    },
                                ),
                                inner_spec: Some(
                                    InnerSpec {
                                        child_order: [
                                            0,
                                            1,
                                        ],
                                        child_size: 32,
                                        min_prefix_length: 1,
                                        max_prefix_length: 1,
                                        empty_child: [],
                                        hash: Sha256,
                                    },
                                ),
                                max_depth: 0,
                                min_depth: 0,
                            },
                        ),
                    ],
                ),
                upgrade_path: [
                    &quot;upgrade&quot;,
                    &quot;upgradedIBCState&quot;,
                ],
                allow_update: AllowUpdate {
                    after_expiry: true,
                    after_misbehaviour: true,
                },
                frozen_height: None,
            },
        ),
    },
)
</code></pre>
<p><strong>JSON:</strong></p>
<pre><code class="language-shell">    hermes --json query channel client --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;
</code></pre>
<p>If the command is successful a message with the following format will be displayed:</p>
<pre><code class="language-json">{
    &quot;result&quot;:
    {
        &quot;client_id&quot;:&quot;07-tendermint-0&quot;,
        &quot;client_state&quot;:
        {
            &quot;allow_update&quot;:
            {
                &quot;after_expiry&quot;:true,
                &quot;after_misbehaviour&quot;:true
            },
            &quot;chain_id&quot;:&quot;network2&quot;,
            &quot;frozen_height&quot;:null,
            &quot;latest_height&quot;:
            {
                &quot;revision_height&quot;:2775,
                &quot;revision_number&quot;:0
            },
            &quot;max_clock_drift&quot;:
            {
                &quot;nanos&quot;:0,
                &quot;secs&quot;:40
            },
            &quot;proof_specs&quot;:
            [
                {
                    &quot;inner_spec&quot;:
                    {
                        &quot;child_order&quot;:[0,1],
                        &quot;child_size&quot;:33,
                        &quot;empty_child&quot;:&quot;&quot;,
                        &quot;hash&quot;:1,
                        &quot;max_prefix_length&quot;:12,
                        &quot;min_prefix_length&quot;:4
                    },
                    &quot;leaf_spec&quot;:
                    {
                        &quot;hash&quot;:1,
                        &quot;length&quot;:1,
                        &quot;prefix&quot;:&quot;AA==&quot;,
                        &quot;prehash_key&quot;:0,
                        &quot;prehash_value&quot;:1
                    },
                    &quot;max_depth&quot;:0,
                    &quot;min_depth&quot;:0
                },
                {
                    &quot;inner_spec&quot;:
                    {
                        &quot;child_order&quot;:[0,1],
                        &quot;child_size&quot;:32,
                        &quot;empty_child&quot;:&quot;&quot;,
                        &quot;hash&quot;:1,
                        &quot;max_prefix_length&quot;:1,
                        &quot;min_prefix_length&quot;:1
                    },
                    &quot;leaf_spec&quot;:
                    {
                        &quot;hash&quot;:1,
                        &quot;length&quot;:1,
                        &quot;prefix&quot;:&quot;AA==&quot;,
                        &quot;prehash_key&quot;:0,
                        &quot;prehash_value&quot;:1
                    },
                    &quot;max_depth&quot;:0,
                    &quot;min_depth&quot;:0
                }
            ],
            &quot;trust_level&quot;:
            {
                &quot;denominator&quot;:3,
                &quot;numerator&quot;:1
            },
            &quot;trusting_period&quot;:
            {
                &quot;nanos&quot;:0,
                &quot;secs&quot;:1209600
            },
            &quot;type&quot;:&quot;Tendermint&quot;,
            &quot;unbonding_period&quot;:
            {
                &quot;nanos&quot;:0,
                &quot;secs&quot;:1814400
            },
            &quot;upgrade_path&quot;:[&quot;upgrade&quot;,&quot;upgradedIBCState&quot;]
        },
        &quot;type&quot;:&quot;IdentifiedAnyClientState&quot;
    },
    &quot;status&quot;:&quot;success&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-queries"><a class="header" href="#packet-queries">Packet Queries</a></h1>
<p>Use the <code>query packet</code> commands to query information about packets.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    ack                   Query packet acknowledgment
    acks                  Query packet acknowledgments
    commitment            Query packet commitment
    commitments           Query packet commitments
    pending               Output a summary of pending packets in both directions
    pending-acks          Query pending acknowledgments
    pending-sends         Query pending packets
    help                  Print this message or the help of the given subcommand(s)
</code></pre>
<h2 id="table-of-contents-11"><a class="header" href="#table-of-contents-11">Table of Contents</a></h2>
<ul>
<li><a href="commands/queries/packet.html#pending-packets">Pending Packets</a></li>
<li><a href="commands/queries/packet.html#packet-commitments">Packet Commitments</a></li>
<li><a href="commands/queries/packet.html#packet-commitment-with-sequence">Packet Commitment with Sequence</a></li>
<li><a href="commands/queries/packet.html#packet-acknowledgments">Packet Acknowledgments</a></li>
<li><a href="commands/queries/packet.html#packet-acknowledgment-with-sequence">Packet Acknowledgment with Sequence</a></li>
<li><a href="commands/queries/packet.html#unreceived-packets">Unreceived Packets</a></li>
<li><a href="commands/queries/packet.html#unreceived-acknowledgments">Unreceived Acknowledgments</a></li>
</ul>
<h2 id="pending-packets"><a class="header" href="#pending-packets">Pending Packets</a></h2>
<p>Use the <code>query packet pending</code> command to query the sequence numbers of all packets that have not yet been received or acknowledged, at both ends of a channel.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet pending --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

DESCRIPTION:
    Output a summary of pending packets in both directions

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain at one end of the channel
        --channel &lt;CHANNEL_ID&gt;    Channel identifier on the chain given by &lt;CHAIN_ID&gt; [aliases:
                                  chan]
        --port &lt;PORT_ID&gt;          Port identifier on the chain given by &lt;CHAIN_ID&gt;
</code></pre>
<p><strong>Example</strong></p>
<p>Query the sequence numbers of all packets that either not yet been received or not yet been acknowledged, at both ends of the channel <code>channel-1</code>.</p>
<pre><code class="language-shell">$ hermes query packet pending --chain ibc-0 --port transfer --channel channel-1
</code></pre>
<pre><code class="language-json">Success: Summary {
    forward: PendingPackets {
        unreceived_packets: [
            2203,
            ...
            2212,
        ],
        unreceived_acks: [
           2183,
           ...
           2202,
        ],
    },
    reverse: PendingPackets {
        unreceived_packets: [
           14,
           ...
           23,
        ],
        unreceived_acks: [
           4,
           ...
           13,
        ],
    },
}
</code></pre>
<h2 id="packet-commitments"><a class="header" href="#packet-commitments">Packet Commitments</a></h2>
<p>Use the <code>query packet commitments</code> command to query the sequence numbers of all packets that have been sent but not yet acknowledged (these are the packets that still have their commitments stored).</p>
<pre><code class="language-shell">USAGE:
    hermes query packet commitments --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

DESCRIPTION:
    Query packet commitments

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the sequence numbers of packets that still have commitments on <code>ibc-0</code> and that were sent on <code>transfer</code> port and <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes query packet commitments --chain ibc-0 --port transfer --channel channel-0
</code></pre>
<pre><code class="language-json">Success: PacketSeqs {
    height: Height {
        revision: 0,
        height: 9154,
    },
    seqs: [
        1,
        2,
        3
    ],
}
</code></pre>
<h2 id="packet-commitment-with-sequence"><a class="header" href="#packet-commitment-with-sequence">Packet Commitment with Sequence</a></h2>
<p>Use the <code>query packet commitment</code> command to query the commitment value of a packet with a given sequence number.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet commitment [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt; --sequence &lt;SEQUENCE&gt;

DESCRIPTION:
    Query packet commitment

OPTIONS:
        --height &lt;HEIGHT&gt;    Height of the state to query. Leave unspecified for latest height.

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
        --sequence &lt;SEQUENCE&gt;     Sequence of packet to query [aliases: seq]
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the commitment of packet with sequence <code>3</code> sent on <code>transfer</code> port and <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes query packet commitment --chain ibc-0 --port transfer --channel channel-0 --sequence 3
</code></pre>
<pre><code class="language-json">Success: &quot;F9458DC7EBEBCD6D18E983FCAB5BD752CC2A74532BBD50B812DB229997739EFC&quot;
</code></pre>
<h2 id="packet-acknowledgments"><a class="header" href="#packet-acknowledgments">Packet Acknowledgments</a></h2>
<p>Use the <code>query packet acknowledgments</code> command to query the sequence numbers of all packets that have been acknowledged.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet acks --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

DESCRIPTION:
    Query packet acknowledgments

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the sequence numbers of packets acknowledged that were received on <code>transfer</code> port and <code>channel-1</code>:</p>
<pre><code class="language-shell">hermes query packet acks --chain ibc-1 --port transfer --channel channel-1
</code></pre>
<pre><code class="language-json">Success: PacketSeqs {
    height: Height {
        revision: 1,
        height: 9547,
    },
    seqs: [
        1,
        2,
        3
    ],
}
</code></pre>
<h2 id="packet-acknowledgment-with-sequence"><a class="header" href="#packet-acknowledgment-with-sequence">Packet Acknowledgment with Sequence</a></h2>
<p>Use the <code>query packet acknowledgment</code> command to query the acknowledgment value of a packet with a given sequence number.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet ack [OPTIONS] --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt; --sequence &lt;SEQUENCE&gt;

DESCRIPTION:
    Query packet acknowledgment

OPTIONS:
        --height &lt;HEIGHT&gt;    Height of the state to query. Leave unspecified for latest height.

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query
        --channel &lt;CHANNEL_ID&gt;    Identifier of the channel to query [aliases: chan]
        --port &lt;PORT_ID&gt;          Identifier of the port to query
        --sequence &lt;SEQUENCE&gt;     Sequence of packet to query [aliases: seq]
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the acknowledgment of packet with sequence <code>2</code> received on <code>transfer</code> port and <code>channel-1</code>:</p>
<pre><code class="language-shell">hermes query packet ack --chain ibc-1 --port transfer --channel channel-1 --sequence 2
</code></pre>
<pre><code class="language-json">Success: &quot;08F7557ED51826FE18D84512BF24EC75001EDBAF2123A477DF72A0A9F3640A7C&quot;
</code></pre>
<h2 id="unreceived-packets"><a class="header" href="#unreceived-packets">Unreceived Packets</a></h2>
<p>Use the <code>query packet pending-sends</code> command to query the sequence numbers of all packets that have been sent on the source chain but not yet received on the destination chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet pending-sends --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

DESCRIPTION:
    Query pending packets

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain for the pending sequences
        --channel &lt;CHANNEL_ID&gt;    Channel identifier [aliases: chan]
        --port &lt;PORT_ID&gt;          Port identifier
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>transfer</code> port and <code>channel-1</code> on <code>ibc-1</code> for the sequence numbers of packets sent on <code>ibc-0</code> but not yet received:</p>
<pre><code class="language-shell">hermes query packet pending-sends --chain ibc-1 --port transfer --channel channel-1
</code></pre>
<pre><code class="language-json">Success: [
    1,
    2,
    3
]
</code></pre>
<h2 id="unreceived-acknowledgments"><a class="header" href="#unreceived-acknowledgments">Unreceived Acknowledgments</a></h2>
<p>Use the <code>query packet pending-acks</code> command to query the sequence numbers of all packets that have not yet been acknowledged.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet pending-acks --chain &lt;CHAIN_ID&gt; --port &lt;PORT_ID&gt; --channel &lt;CHANNEL_ID&gt;

DESCRIPTION:
    Query pending acknowledgments

REQUIRED:
        --chain &lt;CHAIN_ID&gt;        Identifier of the chain to query the pending acknowledgments
        --channel &lt;CHANNEL_ID&gt;    Channel identifier [aliases: chan]
        --port &lt;PORT_ID&gt;          Port identifier
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>transfer</code> port and <code>channel-0</code> on <code>ibc-0</code> for the sequence numbers of packets received by <code>ibc-1</code> but not yet acknowledged on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query packet pending-acks --chain ibc-0 --port transfer --channel channel-0
</code></pre>
<pre><code class="language-json">Success: [
    1,
    2,
    3
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tx-queries"><a class="header" href="#tx-queries">Tx Queries</a></h1>
<p>Use the <code>query tx</code> command to query information about transaction(s).</p>
<pre><code class="language-shell">USAGE:
    hermes query tx &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about transactions

SUBCOMMANDS:
    events     Query the events emitted by transaction
</code></pre>
<h2 id="table-of-contents-12"><a class="header" href="#table-of-contents-12">Table of Contents</a></h2>
<ul>
<li><a href="commands/queries/tx.html#transaction-events">Transaction Events</a></li>
</ul>
<h2 id="transaction-events"><a class="header" href="#transaction-events">Transaction Events</a></h2>
<p>Use the <code>query tx events</code> command to obtain a list of events that a chain generated as a consequence of
delivering a transaction.</p>
<pre><code class="language-shell">USAGE:
    hermes query tx events --chain &lt;CHAIN_ID&gt; --hash &lt;HASH&gt;

DESCRIPTION:
    Query the events emitted by transaction

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain to query
        --hash &lt;HASH&gt;         Transaction hash to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query chain <code>ibc-0</code> for the events emitted due to transaction with hash
<code>6EDBBCBCB779F9FC9D6884ACDC4350E69720C4B362E4ACE6C576DE792F837490</code>:</p>
<pre><code class="language-shell">hermes query tx events --chain ibc-0 --hash 6EDBBCBCB779F9FC9D6884ACDC4350E69720C4B362E4ACE6C576DE792F837490
</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 4,
                height: 6628239,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-139&quot;) Sequence(2),
        },
    ),
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer-queries"><a class="header" href="#transfer-queries">Transfer Queries</a></h1>
<p>Use the <code>query transfer</code> command to query information about transfer(s).</p>
<pre><code class="language-shell">USAGE:
    hermes query transfer &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about token transfers

SUBCOMMANDS:
    denom-trace    Query the denomination trace info from a trace hash
</code></pre>
<h2 id="table-of-contents-13"><a class="header" href="#table-of-contents-13">Table of Contents</a></h2>
<ul>
<li><a href="commands/queries/transfer.html#denomination-trace">Denomination Trace</a></li>
</ul>
<h2 id="denomination-trace"><a class="header" href="#denomination-trace">Denomination Trace</a></h2>
<p>Use the <code>query transfer denom-trace</code> command to obtain the path and base denomination of a given trace hash.</p>
<pre><code class="language-shell">USAGE:
    hermes query transfer denom-trace --chain &lt;CHAIN_ID&gt; --hash &lt;HASH&gt;

DESCRIPTION:
    Query the denomination trace info from a trace hash

REQUIRED:
        --chain &lt;CHAIN_ID&gt;    Identifier of the chain
        --hash &lt;HASH&gt;         Trace hash to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query chain <code>ibc-1</code> for the path and base denomination of the trace hash <code>27A6394C3F9FF9C9DCF5DFFADF9BB5FE9A37C7E92B006199894CF1824DF9AC7C</code>:</p>
<pre><code class="language-shell">hermes query transfer denom-trace --chain ibc-1 --hash 27A6394C3F9FF9C9DCF5DFFADF9BB5FE9A37C7E92B006199894CF1824DF9AC7C
</code></pre>
<pre><code class="language-shell">Success: base_denom: samoleans
 path: transfer/channel-0
</code></pre>
<p>Or with a JSON output:</p>
<pre><code class="language-shell">hermes query transfer denom-trace --chain ibc-1 --hash 27A6394C3F9FF9C9DCF5DFFADF9BB5FE9A37C7E92B006199894CF1824DF9AC7C
</code></pre>
<pre><code class="language-json">{
    &quot;result&quot;:{
        &quot;base_denom&quot;:&quot;samoleans&quot;,
        &quot;path&quot;:&quot;transfer/channel-0&quot;
    },
    &quot;status&quot;:&quot;success&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p>There are a number of simple commands that perform minimal validation, build and send IBC transactions.</p>
<p>The <code>tx</code> command provides the following sub-commands:</p>
<div class="table-wrapper"><table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>conn-init</code></td><td><a href="commands/tx/./connection.html#connection-init">Initialize a connection (ConnectionOpenInit)</a></td></tr>
<tr><td><code>conn-try</code></td><td><a href="commands/tx/./connection.html#connection-try">Relay the connection attempt (ConnectionOpenTry)</a></td></tr>
<tr><td><code>conn-ack</code></td><td><a href="commands/tx/./connection.html#connection-ack">Relay acknowledgment of a connection attempt (ConnectionOpenAck)</a></td></tr>
<tr><td><code>conn-confirm</code></td><td><a href="commands/tx/./connection.html#connection-confirm">Confirm opening of a connection (ConnectionOpenConfirm)</a></td></tr>
<tr><td><code>chan-open-init</code></td><td><a href="commands/tx/./channel-open.html#channel-open-init">Initialize a channel (ChannelOpenInit)</a></td></tr>
<tr><td><code>chan-open-try</code></td><td><a href="commands/tx/./channel-open.html#channel-open-try">Relay the channel attempt (ChannelOpenTry)</a></td></tr>
<tr><td><code>chan-open-ack</code></td><td><a href="commands/tx/./channel-open.html#channel-open-ack">Relay acknowledgment of a channel attempt (ChannelOpenAck)</a></td></tr>
<tr><td><code>chan-open-confirm</code></td><td><a href="commands/tx/./channel-open.html#channel-open-close">Confirm opening of a channel (ChannelOpenConfirm)</a></td></tr>
<tr><td><code>chan-close-init</code></td><td><a href="commands/tx/./channel-close.html#channel-close-init">Initiate the closing of a channel (ChannelCloseInit)</a></td></tr>
<tr><td><code>chan-close-confirm</code></td><td><a href="commands/tx/./channel-close.html#channel-close-confirm">Confirm the closing of a channel (ChannelCloseConfirm)</a></td></tr>
<tr><td><code>ft-transfer</code></td><td><a href="commands/tx/./packet.html#fungible-token-transfer">Send a fungible token transfer test transaction (ICS20 MsgTransfer</a></td></tr>
<tr><td><code>packet-recv</code></td><td><a href="commands/tx/./packet.html#relay-receive-and-timeout-packets">Relay receive or timeout packets</a></td></tr>
<tr><td><code>packet-ack</code></td><td><a href="commands/tx/./packet.html#relay-acknowledgment-packets">Relay acknowledgment packets</a></td></tr>
<tr><td><code>upgrade-chain</code></td><td><a href="commands/tx/./upgrade.html">Send an IBC upgrade plan</a></td></tr>
</tbody></table>
</div>
<p>The main purpose of these commands is to support development and testing, and continuous integration. These CLIs take quite a few parameters and they are explained in the individual sub-sections.</p>
<p>At a high level, most commands follow this template:</p>
<pre><code class="language-shell">hermes tx &lt;ibc-message&gt; &lt;dst-chain-id&gt; &lt;src-chain-id&gt; [-d &lt;dst-obj-id&gt; -s &lt;src-obj-id&gt;]*
</code></pre>
<p>In the command template above:</p>
<ul>
<li>
<p><code>ibc-message</code> - identifies the &quot;main&quot; IBC message that is being sent, e.g. <code>conn-init</code>, <code>conn-try</code>, <code>chan-open-init</code>, etc. To ensure successful processing on the receiving chain, the majority of these commands build and send two messages: one <code>UpdateClient</code> message followed by the actual IBC message. These two messages are included in a single transaction. This is done for all IBC messages that include proofs collected from the source chain.</p>
<p>The messages that do not require proofs are:</p>
<ul>
<li><code>MsgConnectionOpenInit</code> (<code>conn-open-init</code> command),</li>
<li><code>MsgChannelOpenInit</code> (<code>chan-open-init</code> command),</li>
<li><code>MsgChannelCloseInit</code> (<code>chan-close-init</code> command) and</li>
<li><code>MsgTransfer</code> (<code>ft-transfer</code> command)</li>
</ul>
</li>
<li>
<p><code>dst-chain-id</code> - is the identifier of the chain where the transaction will be sent.</p>
</li>
<li>
<p><code>src-chain-id</code> - is the identifier of the chain that is queried for the data that is included in the transaction, e.g. connection data, client proofs, etc. To ensure correct on-chain state, the relayer also queries the destination chain, however it does not include this information in the Tx to the destination chain.</p>
</li>
<li>
<p><code>dst-obj-id</code> - the identifier of an object on destination chain required by the message, e.g. the <code>client-id</code> associated with the connection on destination chain in connection messages. Or the <code>connection-id</code> in a <code>ConnOpenAck</code> message.</p>
</li>
<li>
<p><code>src-obj-id</code> - the identifier of an object on the source chain, required by the message, e.d. the <code>client-id</code> of the connection on source chain.</p>
</li>
<li>
<p>More details about the <code>tx</code> commands can be found in the following sections:</p>
<ul>
<li><a href="commands/tx/./connection.html">Connection</a></li>
<li><a href="commands/tx/./channel-open.html">Channel Open</a></li>
<li><a href="commands/tx/./channel-close.html">Channel Close</a></li>
<li><a href="commands/tx/./packet.html">Packet</a></li>
<li><a href="commands/tx/./upgrade.html">Upgrade</a></li>
</ul>
</li>
</ul>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><code class="language-shell">USAGE:
    hermes tx &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Raw commands for sending transactions to a configured chain.

SUBCOMMANDS:
    help                Get usage information
    conn-init           Initialize a connection (ConnectionOpenInit)
    conn-try            Relay the connection attempt (ConnectionOpenTry)
    conn-ack            Relay acknowledgment of a connection attempt (ConnectionOpenAck)
    conn-confirm        Confirm opening of a connection (ConnectionOpenConfirm)
    chan-open-init      Initialize a channel (ChannelOpenInit)
    chan-open-try       Relay the channel attempt (ChannelOpenTry)
    chan-open-ack       Relay acknowledgment of a channel attempt (ChannelOpenAck)
    chan-open-confirm   Confirm opening of a channel (ChannelOpenConfirm)
    chan-close-init     Initiate the closing of a channel (ChannelCloseInit)
    chan-close-confirm  Confirm the closing of a channel (ChannelCloseConfirm)
    ft-transfer         Send a fungible token transfer test transaction (ICS20 MsgTransfer)
    packet-recv         Relay receive or timeout packets
    packet-ack          Relay acknowledgment packets
    upgrade-chain       Send an IBC upgrade plan
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection-handshake"><a class="header" href="#connection-handshake">Connection Handshake</a></h1>
<p>The <code>tx</code> commands can be used to establish a connection between two clients.</p>
<center>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant A as ibc-1
    participant B as ibc-0
    Note over A, B: No connection
    A-&gt;&gt;B: ConnectionOpenInit
    Note over B: connection: connection-0
    Note over B: counterparty: none
    B-&gt;&gt;A: ConnectionOpenTry
    Note over A: connection: connection-1
    Note over A: counterparty: connection-0
    A-&gt;&gt;B: ConnectionOpenAck
    note over B: connection: connection-0
    note over B: counterparty: connection-1
    B-&gt;&gt;A: ConnectionOpenConfirm
    Note over A, B: Connection open
</pre>
</center>
<h2 id="table-of-contents-14"><a class="header" href="#table-of-contents-14">Table of Contents</a></h2>
<ul>
<li><a href="commands/tx/connection.html#connection-init">Connection Init</a></li>
<li><a href="commands/tx/connection.html#connection-try">Connection Try</a></li>
<li><a href="commands/tx/connection.html#connection-ack">Connection Ack</a></li>
<li><a href="commands/tx/connection.html#connection-confirm">Connection Confirm</a></li>
</ul>
<h2 id="connection-init"><a class="header" href="#connection-init">Connection Init</a></h2>
<p>Use the <code>conn-init</code> command to initialize a new connection on a chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx conn-init --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-client &lt;DST_CLIENT_ID&gt; --src-client &lt;SRC_CLIENT_ID&gt;

DESCRIPTION:
    Initialize a connection (ConnectionOpenInit)

REQUIRED:
        --src-chain &lt;SRC_CHAIN_ID&gt;      Identifier of the source chain
        --src-client &lt;SRC_CLIENT_ID&gt;    Identifier of the source client
        --dst-chain &lt;DST_CHAIN_ID&gt;      Identifier of the destination chain
        --dst-client &lt;DST_CLIENT_ID&gt;    Identifier of the destination client
</code></pre>
<p><strong>Example</strong></p>
<p>Given that two clients were previously created with identifier <code>07-tendermint-0</code> on chain <code>ibc-0</code> and
identifier <code>07-tendermint-1</code> on chain <code>ibc-1</code>, we can initialize a connection between the two clients.</p>
<p>First, let's initialize the connection on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx conn-init --dst-chain ibc-0 --src-chain ibc-1 --dst-client 07-tendermint-0 --src-client 07-tendermint-1
</code></pre>
<pre><code class="language-json">Success: OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 73,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
        },
    ),
)
</code></pre>
<p>A new connection has been initialized on <code>ibc-0</code> with identifier <code>connection-0</code>.</p>
<blockquote>
<p>Note that the <code>counterparty_connection_id</code> field is currently empty.</p>
</blockquote>
<h2 id="connection-try"><a class="header" href="#connection-try">Connection Try</a></h2>
<p>Use the <code>conn-try</code> command to establish a counterparty to the connection on the other chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx conn-try [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-client &lt;DST_CLIENT_ID&gt; --src-client &lt;SRC_CLIENT_ID&gt; --src-connection &lt;SRC_CONNECTION_ID&gt;

DESCRIPTION:
    Relay the connection attempt (ConnectionOpenTry)

OPTIONS:
        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection (optional) [aliases: dst-conn]

REQUIRED:
        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-client &lt;SRC_CLIENT_ID&gt;
            Identifier of the source client

        --src-connection &lt;SRC_CONNECTION_ID&gt;
            Identifier of the source connection (required) [aliases: src-conn]

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-client &lt;DST_CLIENT_ID&gt;
            Identifier of the destination client
</code></pre>
<p><strong>Example</strong></p>
<p>Let's now create the counterparty to <code>connection-0</code> on chain <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx conn-try --dst-chain ibc-1 --src-chain ibc-0 --dst-client 07-tendermint-1 --src-client 07-tendermint-0 --src-connection connection-0
</code></pre>
<pre><code class="language-json">Success: OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height {
                revision: 1,
                height: 88,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-1&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)
</code></pre>
<p>A new connection has been created on <code>ibc-1</code> with identifier <code>connection-1</code>.</p>
<blockquote>
<p>Note that the field <code>counterparty_connection_id</code> points to the connection on <code>ibc-0</code>.</p>
</blockquote>
<h2 id="connection-ack"><a class="header" href="#connection-ack">Connection Ack</a></h2>
<p>Use the <code>conn-ack</code> command to acknowledge the connection on the initial chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx conn-ack --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-client &lt;DST_CLIENT_ID&gt; --src-client &lt;SRC_CLIENT_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --src-connection &lt;SRC_CONNECTION_ID&gt;

DESCRIPTION:
    Relay acknowledgment of a connection attempt (ConnectionOpenAck)

REQUIRED:
        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-client &lt;SRC_CLIENT_ID&gt;
            Identifier of the source client

        --src-connection &lt;SRC_CONNECTION_ID&gt;
            Identifier of the source connection (required) [aliases: src-conn]

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-client &lt;DST_CLIENT_ID&gt;
            Identifier of the destination client

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection (required) [aliases: dst-conn]
</code></pre>
<p><strong>Example</strong></p>
<p>We can now acknowledge on <code>ibc-0</code> that <code>ibc-1</code> has accepted the connection attempt:</p>
<pre><code class="language-shell">hermes tx conn-ack --dst-chain ibc-0 --src-chain ibc-1 --dst-client 07-tendermint-0 --src-client 07-tendermint-1 --dst-connection connection-0 --src-connection connection-1
</code></pre>
<pre><code class="language-json">Success: OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height {
                revision: 0,
                height: 206,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-1&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
        },
    ),
)
</code></pre>
<blockquote>
<p>Note that the field <code>counterparty_connection_id</code> now points to the connection on <code>ibc-1</code>.</p>
</blockquote>
<h2 id="connection-confirm"><a class="header" href="#connection-confirm">Connection Confirm</a></h2>
<p>Use the <code>conn-confirm</code> command to confirm that the connection has been acknowledged,
and finish the handshake, after which the connection is open on both chains.</p>
<pre><code class="language-shell">USAGE:
    hermes tx conn-confirm --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-client &lt;DST_CLIENT_ID&gt; --src-client &lt;SRC_CLIENT_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --src-connection &lt;SRC_CONNECTION_ID&gt;

DESCRIPTION:
    Confirm opening of a connection (ConnectionOpenConfirm)

REQUIRED:
        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-client &lt;SRC_CLIENT_ID&gt;
            Identifier of the source client

        --src-connection &lt;SRC_CONNECTION_ID&gt;
            Identifier of the source connection (required) [aliases: src-conn]

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-client &lt;DST_CLIENT_ID&gt;
            Identifier of the destination client

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection (required) [aliases: dst-conn]
</code></pre>
<p><strong>Example</strong></p>
<p>Confirm on <code>ibc-1</code> that <code>ibc-0</code> has accepted the connection attempt.</p>
<pre><code class="language-shell">hermes tx conn-confirm --dst-chain ibc-1 --src-chain ibc-0 --dst-client 07-tendermint-1 --src-client 07-tendermint-0 --dst-connection connection-1 --src-connection connection-0
</code></pre>
<pre><code class="language-json">Success: OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 239,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-1&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)
</code></pre>
<p>We have now successfully established a connection between the two chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel-open-handshake"><a class="header" href="#channel-open-handshake">Channel Open Handshake</a></h1>
<p>The <code>tx</code> commands can be used to establish a channel for a given connection. Only <code>unordered</code> channels are currently supported.</p>
<center>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant A as ibc-1
    participant B as ibc-0
    Note over A, B: No channel
    A-&gt;&gt;B: ChannelOpenInit
    Note over B: channel: channel-0
    Note over B: channel: counterparty: none
    B-&gt;&gt;A: ChannelOpenTry
    Note over A: channel: channel-1
    Note over A: channel: counterparty: channel-0
    A-&gt;&gt;B: ChannelOpenAck
    note over B: channel: channel-0
    note over B: counterparty: channel-1
    B-&gt;&gt;A: ChannelOpenConfirm
    Note over A, B: Channel open
</pre>
</center>
<h2 id="table-of-contents-15"><a class="header" href="#table-of-contents-15">Table of Contents</a></h2>
<ul>
<li><a href="commands/tx/channel-open.html#channel-open-init">Channel Open Init</a></li>
<li><a href="commands/tx/channel-open.html#channel-open-try">Channel Open Try</a></li>
<li><a href="commands/tx/channel-open.html#channel-open-ack">Channel Open Ack</a></li>
<li><a href="commands/tx/channel-open.html#channel-open-confirm">Channel Open Confirm</a></li>
</ul>
<h2 id="channel-open-init"><a class="header" href="#channel-open-init">Channel Open Init</a></h2>
<p>Use the <code>chan-open-init</code> command to initialize a new channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx chan-open-init [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt;

DESCRIPTION:
    Initialize a channel (ChannelOpenInit)

OPTIONS:
        --order &lt;ORDER&gt;    The channel ordering, valid options 'unordered' (default) and 'ordered'
                           [default: ORDER_UNORDERED]

REQUIRED:
        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port
</code></pre>
<p><strong>Example</strong></p>
<p>First, let's initialize the channel on <code>ibc-0</code> using an existing connection identified by <code>connection-0</code>:</p>
<pre><code class="language-shell">hermes tx chan-open-init --dst-chain ibc-0 --src-chain ibc-1 --dst-connection connection-0 --dst-port transfer --src-port transfer
</code></pre>
<pre><code class="language-json">Success: OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 3091
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: None,
        },
    ),
)
</code></pre>
<p>A new channel has been initialized on <code>ibc-1</code> with identifier <code>channel-0</code>.</p>
<blockquote>
<p>Note that the <code>counterparty_channel_id</code> field is currently empty.</p>
</blockquote>
<h2 id="channel-open-try"><a class="header" href="#channel-open-try">Channel Open Try</a></h2>
<p>Use the <code>chan-open-try</code> command to establish a counterparty to the channel on the other chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx chan-open-try [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

DESCRIPTION:
    Relay the channel attempt (ChannelOpenTry)

OPTIONS:
        --dst-channel &lt;DST_CHANNEL_ID&gt;    Identifier of the destination channel (optional) [aliases:
                                      b-chan]

REQUIRED:
        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel (required) [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port
</code></pre>
<p><strong>Example</strong></p>
<p>Let's now create the counterparty to <code>channel-0</code> on chain <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx chan-open-try --dst-chain ibc-1 --src-chain ibc-0 --dst-connection connection-1 --dst-port transfer --src-port transfer --src-channel channel-0
</code></pre>
<pre><code class="language-json">Success: OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height {
                revision: 1,
                height: 3213
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-1&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
        },
    ),
)
</code></pre>
<p>A new channel has been created on <code>ibc-1</code> with identifier <code>channel-1</code>.</p>
<blockquote>
<p>Note that the field <code>counterparty_channel_id</code> points to the channel on <code>ibc-0</code>.</p>
</blockquote>
<h2 id="channel-open-ack"><a class="header" href="#channel-open-ack">Channel Open Ack</a></h2>
<p>Use the <code>chan-open-ack</code> command to acknowledge the channel on the initial chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx chan-open-ack --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --dst-channel &lt;DST_CHANNEL_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

DESCRIPTION:
    Relay acknowledgment of a channel attempt (ChannelOpenAck)

REQUIRED:
        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel (required) [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-channel &lt;DST_CHANNEL_ID&gt;
            Identifier of the destination channel (required) [aliases: dst-chan]

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port
</code></pre>
<p><strong>Example</strong></p>
<p>We can now acknowledge on <code>ibc-0</code> that <code>ibc-1</code> has accepted the opening of the channel:</p>
<pre><code class="language-shell">hermes tx chan-open-ack --dst-chain ibc-0 --src-chain ibc-1 --dst-connection connection-0 --dst-port transfer --src-port transfer --dst-channel channel-0 --src-channel channel-1
</code></pre>
<pre><code class="language-json">Success: OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height {
                revision: 0,
                height: 3301
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
        },
    ),
)
</code></pre>
<blockquote>
<p>Note that the field <code>counterparty_channel_id</code> now points to the channel on <code>ibc-1</code>.</p>
</blockquote>
<h2 id="channel-open-confirm"><a class="header" href="#channel-open-confirm">Channel Open Confirm</a></h2>
<p>Use the <code>chan-open-confirm</code> command to confirm that the channel has been acknowledged,
and finish the handshake, after which the channel is open on both chains.</p>
<pre><code class="language-shell">USAGE:
    hermes tx chan-open-confirm --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --dst-channel &lt;DST_CHANNEL_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

DESCRIPTION:
    Confirm opening of a channel (ChannelOpenConfirm)

REQUIRED:
        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel (required) [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-channel &lt;DST_CHANNEL_ID&gt;
            Identifier of the destination channel (required) [aliases: dst-chan]

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port
</code></pre>
<p><strong>Example</strong></p>
<p>Confirm on <code>ibc-1</code> that <code>ibc-0</code> has accepted the opening of the channel,
after which the channel is open on both chains.</p>
<pre><code class="language-shell">hermes tx chan-open-confirm --dst-chain ibc-1 --src-chain ibc-0 --dst-connection connection-1 --dst-port transfer --src-port transfer --dst-channel channel-1 --src-channel channel-0
</code></pre>
<pre><code class="language-json">    OpenConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 3483
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-1&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
        },
    ),
)
</code></pre>
<p>We have now successfully opened a channel over an existing connection between the two chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel-close-handshake"><a class="header" href="#channel-close-handshake">Channel Close Handshake</a></h1>
<p>The channel close handshake involves two steps: init and confirm.</p>
<h2 id="table-of-contents-16"><a class="header" href="#table-of-contents-16">Table of Contents</a></h2>
<ul>
<li><a href="commands/tx/channel-close.html#channel-close-init">Channel Close Init</a></li>
<li><a href="commands/tx/channel-close.html#channel-close-confirm">Channel Close Confirm</a></li>
</ul>
<h2 id="channel-close-init"><a class="header" href="#channel-close-init">Channel Close Init</a></h2>
<p>Use the <code>chan-close-init</code> command to initialize the closure of a channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx chan-close-init --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --dst-channel &lt;DST_CHANNEL_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

DESCRIPTION:
    Initiate the closing of a channel (ChannelCloseInit)

REQUIRED:
        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel (required) [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-channel &lt;DST_CHANNEL_ID&gt;
            Identifier of the destination channel (required) [aliases: dst-chan]

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes tx chan-close-init --dst-chain ibc-0 --src-chain ibc-1 --dst-connection connection-0 --dst-port transfer --src-port transfer --dst-channel channel-0 --src-channel channel-1
</code></pre>
<pre><code class="language-json">Success: CloseInitChannel(
    CloseInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 77,
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
        },
    ),
)
</code></pre>
<h2 id="channel-close-confirm"><a class="header" href="#channel-close-confirm">Channel Close Confirm</a></h2>
<p>Use the <code>chan-close-confirm</code> command to confirm the closure of a channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx chan-close-confirm --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --dst-connection &lt;DST_CONNECTION_ID&gt; --dst-port &lt;DST_PORT_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --dst-channel &lt;DST_CHANNEL_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt;

DESCRIPTION:
    Confirm the closing of a channel (ChannelCloseConfirm)

REQUIRED:
        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel (required) [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --dst-channel &lt;DST_CHANNEL_ID&gt;
            Identifier of the destination channel (required) [aliases: dst-chan]

        --dst-connection &lt;DST_CONNECTION_ID&gt;
            Identifier of the destination connection [aliases: dst-conn]

        --dst-port &lt;DST_PORT_ID&gt;
            Identifier of the destination port

</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes tx chan-close-confirm --dst-chain ibc-1 --src-chain ibc-0 --dst-connection connection-1 --src-port transfer --dst-port transfer --dst-channel channel-1 --src-channel channel-0
</code></pre>
<pre><code class="language-json">Success: CloseConfirmChannel(
    CloseConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 551,
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-1&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
        },
    ),
)
</code></pre>
<p><strong>NOTE</strong>: The <code>cosmos-sdk</code> transfer module implementation does not allow the user (<code>hermes</code> in this case) to initiate the closing of channels.
Therefore, when using the Gaia release image, the <code>chan-close-init</code> command
fails as the <code>MsgChannelCloseInit</code> message included in the transaction is rejected.
To be able to test channel closure, you need to <a href="commands/tx/../../help.html#patching-gaia">patch</a> your gaia deployments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-tx-commands"><a class="header" href="#packet-tx-commands">Packet Tx Commands</a></h1>
<h2 id="table-of-contents-17"><a class="header" href="#table-of-contents-17">Table of Contents</a></h2>
<ul>
<li><a href="commands/tx/packet.html#fungible-token-transfer">Fungible token transfer</a></li>
<li><a href="commands/tx/packet.html#relay-receive-and-timeout-packets">Relay receive and timeout packets</a></li>
<li><a href="commands/tx/packet.html#relay-acknowledgment-packets">Relay acknowledgment packets</a></li>
</ul>
<h2 id="fungible-token-transfer"><a class="header" href="#fungible-token-transfer">Fungible token transfer</a></h2>
<p>Use the <code>tx ft-transfer</code> command to send ICS-20 fungible token transfer packets.
<strong>NOTE:</strong> This command is mainly used for testing the packet features of the relayer.</p>
<pre><code class="language-shell">USAGE:
    hermes tx ft-transfer [OPTIONS] --dst-chain &lt;DST_CHAIN_ID&gt; --src-chain &lt;SRC_CHAIN_ID&gt; --src-port &lt;SRC_PORT_ID&gt; --src-channel &lt;SRC_CHANNEL_ID&gt; --amount &lt;AMOUNT&gt;

OPTIONS:
        --denom &lt;DENOM&gt;
            Denomination of the coins to send [default: samoleans]

    -h, --help
            Print help information

        --key-name &lt;KEY_NAME&gt;
            Use the given signing key name (default: `key_name` config)

        --number-msgs &lt;NUMBER_MSGS&gt;
            Number of messages to send

        --receiver &lt;RECEIVER&gt;
            The account address on the destination chain which will receive the tokens. If omitted,
            the relayer's wallet on the destination chain will be used

        --timeout-height-offset &lt;TIMEOUT_HEIGHT_OFFSET&gt;
            Timeout in number of blocks since current [default: 0]

        --timeout-seconds &lt;TIMEOUT_SECONDS&gt;
            Timeout in seconds since current [default: 0]

REQUIRED:
        --amount &lt;AMOUNT&gt;
            Amount of coins (samoleans, by default) to send (e.g. `100000`)

        --dst-chain &lt;DST_CHAIN_ID&gt;
            Identifier of the destination chain

        --src-chain &lt;SRC_CHAIN_ID&gt;
            Identifier of the source chain

        --src-channel &lt;SRC_CHANNEL_ID&gt;
            Identifier of the source channel [aliases: src-chan]

        --src-port &lt;SRC_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>Send two transfer packets from the <code>transfer</code> module and <code>channel-0</code> of <code>ibc-0</code> to <code>ibc-1</code>. Each transfer if for <code>9999</code> samoleans (default denomination) and a timeout offset of <code>10</code> blocks. The transfer fee is paid by the relayer account on <code>ibc-1</code>.</p>
<pre><code class="language-shell">hermes tx ft-transfer --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-0 --amount 9999 --timeout-height-offset 1000 --number-msgs 2
</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 431,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
        },
    ),
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 431,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(5),
        },
    ),
]
</code></pre>
<p>The transfer packets are stored on <code>ibc-0</code> and can be relayed.</p>
<blockquote>
<p>To send transfer packets with a custom receiver address use the <code>--receiver</code> flag.</p>
</blockquote>
<pre><code class="language-shell">hermes tx ft-transfer --dst-chain ibc-1 --src-chain ibc-0 --src-port transfer --src-channel channel-0 --amount 9999 --timeout-height-offset 1000 --number-msgs 1 --receiver board:1938586739
</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 546,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(7),
        },
    ),
]
</code></pre>
<h2 id="relay-receive-and-timeout-packets"><a class="header" href="#relay-receive-and-timeout-packets">Relay receive and timeout packets</a></h2>
<p>Use the <code>tx packet-recv</code> command to relay the packets sent but not yet received. If the sent packets have timed out then a timeout packet is sent to the source chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx packet-recv --reference-chain &lt;REFERENCE_CHAIN_ID&gt; --host-chain &lt;HOST_CHAIN_ID&gt; --host-port &lt;HOST_PORT_ID&gt; --host-channel &lt;HOST_CHANNEL_ID&gt;

DESCRIPTION:
    Relay receive or timeout packets

REQUIRED:
        --reference-chain &lt;REFERENCE_CHAIN_ID&gt;
            Identifier of the destination chain

        --host-chain &lt;HOST_CHAIN_ID&gt;
            Identifier of the source chain

        --host-channel &lt;HOST_CHANNEL_ID&gt;
            Identifier of the source channel [aliases: sender-chan]

        --host-port &lt;HOST_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>Send the two transfer packets to the <code>ibc-1</code> module bound to the <code>transfer</code> port and the <code>channel-0</code>'s counterparty.</p>
<p><strong>NOTE</strong>: The relayer prepends a client update message before the receive messages.</p>
<pre><code class="language-shell">hermes tx packet-recv --reference-chain ibc-1 --host-chain ibc-0 --host-port transfer --host-channel channel-0
</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 1,
                    height: 439,
                },
                client_id: ClientId(
                    &quot;07-tendermint-1&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 0,
                    height: 449,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 1,
                height: 439,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
            ack: [
                123,
                34,
                114,
                101,
                115,
                117,
                108,
                116,
                34,
                58,
                34,
                65,
                81,
                61,
                61,
                34,
                125,
            ],
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 1,
                height: 439,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(5),
            ack: [
                123,
                34,
                114,
                101,
                115,
                117,
                108,
                116,
                34,
                58,
                34,
                65,
                81,
                61,
                61,
                34,
                125,
            ],
        },
    ),
]
</code></pre>
<p>Both packets have been relayed to <code>ibc-1</code> and acknowledged.</p>
<h2 id="relay-acknowledgment-packets"><a class="header" href="#relay-acknowledgment-packets">Relay acknowledgment packets</a></h2>
<p>Use the <code>tx packet-ack</code> command to relay acknowledgments to the original source of the packets.</p>
<pre><code class="language-shell">USAGE:
    hermes tx packet-ack --reference-chain &lt;REFERENCE_CHAIN_ID&gt; --host-chain &lt;HOST_CHAIN_ID&gt; --host-port &lt;HOST_PORT_ID&gt; --host-channel &lt;HOST_CHANNEL_ID&gt;

DESCRIPTION:
    Relay acknowledgment packets

REQUIRED:
        --reference-chain &lt;REFERENCE_CHAIN_ID&gt;
            Identifier of the destination chain

        --host-chain &lt;HOST_CHAIN_ID&gt;
            Identifier of the source chain

        --host-channel &lt;HOST_CHANNEL_ID&gt;
            Identifier of the source channel [aliases: sender-chan]

        --host-port &lt;HOST_PORT_ID&gt;
            Identifier of the source port
</code></pre>
<p><strong>Example</strong></p>
<p>Send the acknowledgments to the <code>ibc-0</code> module bound to the <code>transfer</code> port and the <code>channel-1</code>'s counterparty.</p>
<p><strong>NOTE</strong>: The relayer prepends a client update message before the acknowledgments.</p>
<pre><code class="language-shell">hermes tx packet-ack --reference-chain ibc-0 --host-chain ibc-1 --host-port transfer --host-channel channel-1
</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 495,
                },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 483,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 495,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 495,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(5),
        },
    ),
]
</code></pre>
<p>Both acknowledgments have been received on <code>ibc-0</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-tx-commands"><a class="header" href="#upgrade-tx-commands">Upgrade Tx Commands</a></h1>
<h2 id="table-of-contents-18"><a class="header" href="#table-of-contents-18">Table of Contents</a></h2>
<ul>
<li><a href="commands/tx/upgrade.html#upgrade-chain">Upgrade Chain</a></li>
</ul>
<h2 id="upgrade-chain"><a class="header" href="#upgrade-chain">Upgrade Chain</a></h2>
<p>Use this to make an upgrade proposal.</p>
<pre><code class="language-shell">USAGE:
    hermes tx upgrade-chain [OPTIONS] --reference-chain &lt;REFERENCE_CHAIN_ID&gt; --host-chain &lt;HOST_CHAIN_ID&gt; --host-client &lt;HOST_CLIENT_ID&gt; --amount &lt;AMOUNT&gt; --height-offset &lt;HEIGHT_OFFSET&gt;

DESCRIPTION:
    Send an IBC upgrade plan
 
OPTIONS:
        --denom &lt;DENOM&gt;
            Denomination for the deposit (default: 'stake')

        --new-chain &lt;CHAIN_ID&gt;
            New chain identifier to assign to the upgrading chain (optional)

        --new-unbonding &lt;UNBONDING_PERIOD&gt;
            New unbonding period to assign to the upgrading chain, in seconds (optional)

        --upgrade-name &lt;UPGRADE_NAME&gt;
            A string to name the upgrade proposal plan (default: 'plan')

REQUIRED:
        --amount &lt;AMOUNT&gt;
            Amount of stake

        --height-offset &lt;HEIGHT_OFFSET&gt;
            Upgrade height offset in number of blocks since current

        --reference-chain &lt;REFERENCE_CHAIN_ID&gt;
            Identifier of the chain to upgrade

        --host-chain &lt;HOST_CHAIN_ID&gt;
            Identifier of the source chain

        --host-client &lt;HOST_CLIENT_ID&gt;
            Identifier of the client on source chain from which the plan is created
</code></pre>
<p><strong>Example</strong></p>
<p>An upgrade proposal is made for <code>ibc-0</code>, for height <code>300</code> blocks from latest height, with <code>10000000stake</code> deposited. The proposal will include the upgraded client state constructed from the state of <code>07-tendermint-0</code> client on <code>ibc-1</code>.</p>
<pre><code class="language-shell">hermes tx upgrade-chain --reference-chain ibc-0 --host-chain ibc-1 --host-client 07-tendermint-0 --amount 10000000 --height-offset 300
</code></pre>
<pre><code>Success: transaction::Hash(779713508B6103E37FADE60483BEE964A90BD67E5F20037B2CC4AE0E90B707C3)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help"><a class="header" href="#help">Help</a></h1>
<p>This section provides guidelines regarding troubleshooting and general
resources for getting help with <code>hermes</code>.
For this purpose, we recommend a few ideas that could be of help:</p>
<ul>
<li><a href="./help.html#help-command">hermes help</a> command, providing a CLI
documentation for all <code>hermes</code> commands.</li>
<li><a href="./help.html#profiling">profile</a> your relayer binary to identify slow methods;</li>
<li><a href="./help.html#parametrizing-the-log-output-level">configure</a> the <code>log_level</code> to help with debugging;</li>
<li><a href="./help.html#patching-gaia">patch</a> your local gaia chain(s) to enable some corner-case methods
(e.g., channel close);</li>
</ul>
<p>And if the above options do not address your specific problem:</p>
<ul>
<li>you can <a href="./help.html#new-feature-request">request a new feature</a>;</li>
<li>or consult the <a href="https://github.com/informalsystems/ibc-rs/issues">list of reported issues</a> and search by relevant
keywords to see if you're dealing with a known problem;</li>
<li>we would be grateful if you can submit a <a href="https://github.com/informalsystems/ibc-rs/issues/new?assignees=&amp;labels=&amp;template=bug-report.md">bug report</a>
discussing any problem you find, and from there on we can look at the
problem together;</li>
</ul>
<p>Lastly, for general questions, you can reach us at <code>hello@informal.systems</code>,
or on Twitter <a href="https://twitter.com/informalinc">@informalinc</a>.</p>
<h2 id="table-of-contents-19"><a class="header" href="#table-of-contents-19">Table of contents</a></h2>
<ul>
<li><a href="help.html#help-command">Help command</a></li>
<li><a href="help.html#parametrizing-the-log-output-level">Parametrizing the log output level</a></li>
<li><a href="help.html#overriding-the-tracing-filter-using-rust_log">Overriding the tracing filter using <code>RUST_LOG</code></a></li>
<li><a href="help.html#inspecting-the-relayer-state">Inspecting the relayer state</a></li>
<li><a href="help.html#connecting-to-a-full-node-protected-by-http-basic-authentication">Connecting to a full node protected by HTTP Basic Authentication</a></li>
<li><a href="help.html#patching-gaia-to-support-chancloseinit">Patching <code>gaia</code> to support <code>ChanCloseInit</code></a></li>
<li><a href="help.html#new-feature-request">New Feature Request</a></li>
<li><a href="help.html#profiling">Profiling</a>
<ul>
<li><a href="help.html#setup">Setup</a></li>
<li><a href="help.html#example">Example</a>
<ul>
<li><a href="help.html#output">Output</a></li>
<li><a href="help.html#example-output-for-tx-conn-init-command">Example output for <code>tx conn-init</code> command</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="help-command"><a class="header" href="#help-command">Help command</a></h2>
<p>The CLI comprises a special <code>help</code> command, which accepts as parameter other commands, and provides guidance on what is the correct way to invoke those commands.</p>
<blockquote>
<p><strong>NOTE</strong>: This special <code>help</code> command is preferred as it will display the full help
message.</p>
</blockquote>
<p>For instance,</p>
<pre><code class="language-shell">hermes help create
</code></pre>
<p>will provide details about all the valid invocations of the <code>create</code> CLI command.</p>
<pre><code>USAGE:
    hermes create &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Create objects (client, connection, or channel) on chains

SUBCOMMANDS:
    channel       Create a new channel between two chains
    client        Create a new IBC client
    connection    Create a new connection between two chains
    help          Print this message or the help of the given subcommand(s)
</code></pre>
<p>This can provide further specific guidance if we add additional parameters, e.g., </p>
<pre><code class="language-shell">hermes help create channel
</code></pre>
<pre><code class="language-shell">USAGE:
    hermes create channel [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --a-connection &lt;A_CONNECTION_ID&gt; --a-port &lt;A_PORT_ID&gt; --b-port &lt;B_PORT_ID&gt;

    hermes create channel [OPTIONS] --a-chain &lt;A_CHAIN_ID&gt; --b-chain &lt;B_CHAIN_ID&gt; --a-port &lt;A_PORT_ID&gt; --b-port &lt;B_PORT_ID&gt; --new-client-connection

DESCRIPTION:
    Create a new channel between two chains.

    Can create a new channel using a pre-existing connection or alternatively, create a new client and a
    new connection underlying the new channel if a pre-existing connection is not provided.

OPTIONS:
        --channel-version &lt;VERSION&gt;
            The version for the new channel

            [aliases: chan-version]

        --new-client-connection
            Indicates that a new client and connection will be created underlying the new channel

            [aliases: new-client-conn]

        --order &lt;ORDER&gt;
            The channel ordering, valid options 'unordered' (default) and 'ordered'

            [default: ORDER_UNORDERED]

        --yes
            Skip new_client_connection confirmation

FLAGS:
        --a-chain &lt;A_CHAIN_ID&gt;
            Identifier of the side `a` chain for the new channel

        --a-connection &lt;A_CONNECTION_ID&gt;
            Identifier of the connection on chain `a` to use in creating the new channel

            [aliases: a-conn]

        --a-port &lt;A_PORT_ID&gt;
            Identifier of the side `a` port for the new channel

        --b-chain &lt;B_CHAIN_ID&gt;
            Identifier of the side `b` chain for the new channel

        --b-port &lt;B_PORT_ID&gt;
            Identifier of the side `b` port for the new channel
</code></pre>
<p>Additionally, the <code>-h</code>/<code>--help</code> flags typical for CLI applications work on
all commands.</p>
<h2 id="parametrizing-the-log-output-level"><a class="header" href="#parametrizing-the-log-output-level">Parametrizing the log output level</a></h2>
<p>The relayer configuration file permits parametrization of output verbosity via the knob called <code>log_level</code>.
This file is loaded by default from <code>$HOME/.hermes/config.toml</code>, but can be overridden in all commands
with the <code>--config</code> flag, eg. <code>hermes --config ./path/to/my/config.toml some command</code>.</p>
<p>Relevant snippet:</p>
<pre><code class="language-toml">[global]
log_level = 'error'
</code></pre>
<p>Valid options for <code>log_level</code> are: 'error', 'warn', 'info', 'debug', 'trace'.
These levels correspond to the tracing sub-component of the relayer-cli,
<a href="https://docs.rs/tracing-core/0.1.17/tracing_core/struct.Level.html">see here</a>.</p>
<p>The relayer will <em>always</em> print a last line summarizing the result of its
operation for queries or transactions. In addition to this last line,
arbitrary debug, info, or other outputs may be produced.</p>
<h2 id="overriding-the-tracing-filter-using-rust_log"><a class="header" href="#overriding-the-tracing-filter-using-rust_log">Overriding the tracing filter using <code>RUST_LOG</code></a></h2>
<p>For debugging purposes, we may want to inspect which RPC queries the relayer is making.
The relayer makes use of the <code>tendermint-rpc</code> library to issue RPC queries, but
the output of this library is by default turned off in order to keep the logs more
readable.</p>
<p>Using the <code>RUST_LOG</code> environment variable, we can turn logging on for the
<code>tendermint-rpc</code> library, as follows:</p>
<pre><code>RUST_LOG=tendermint-rpc=debug,info hermes start
</code></pre>
<p>Setting the <code>RUST_LOG</code> environment variable to <code>tendermint_rpc=debug,info</code> instructs
the relayer to set the log level of the <code>tendermint_rpc</code> crate to <code>debug</code> and otherwise
use the <code>info</code> log level.</p>
<blockquote>
<p><strong>Note:</strong> While the <code>tendermint-rpc</code> contains a dash in its name, the logging filter
expects a module name, which can only contain alphanumeric characters and underscores,
hence why the filter above is written <code>tendermint_rpc=debug</code>.</p>
</blockquote>
<p><strong>Example:</strong></p>
<pre><code>❯ RUST_LOG=tendermint_rpc=debug,info hermes start
2022-02-24T14:32:14.039555Z  INFO ThreadId(01) using default configuration from '/Users/coromac/.hermes/config.toml'
2022-02-24T14:32:14.043500Z  INFO ThreadId(01) telemetry service running, exposing metrics at http://127.0.0.1:3001/metrics
2022-02-24T14:32:14.043542Z  INFO ThreadId(01) [rest] address not configured, REST server disabled
2022-02-24T14:32:14.049759Z DEBUG ThreadId(01) Incoming response: {
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;143b4580-c49e-47c1-81b2-4e7090f6e762&quot;,
  &quot;result&quot;: {
    &quot;node_info&quot;: {
      &quot;protocol_version&quot;: {
        &quot;p2p&quot;: &quot;8&quot;,
        &quot;block&quot;: &quot;11&quot;,
        &quot;app&quot;: &quot;0&quot;
      },
      &quot;id&quot;: &quot;73f9134539f9845cd253dc302e36d48ee4c0f32d&quot;,
      &quot;listen_addr&quot;: &quot;tcp://0.0.0.0:27003&quot;,
      &quot;network&quot;: &quot;ibc0&quot;,
      &quot;version&quot;: &quot;v0.34.14&quot;,
      &quot;channels&quot;: &quot;40202122233038606100&quot;,
      &quot;moniker&quot;: &quot;ibc0&quot;,
      &quot;other&quot;: {
        &quot;tx_index&quot;: &quot;on&quot;,
        &quot;rpc_address&quot;: &quot;tcp://0.0.0.0:27000&quot;
      }
    },
    &quot;sync_info&quot;: {
      &quot;latest_block_hash&quot;: &quot;8396B93E355AD80EED8167A04BB9858A315A8BEB482547DE16A6CD82BC11551B&quot;,
      &quot;latest_app_hash&quot;: &quot;22419E041D6997EE75FF66F7F537A3D36122B220EAB89A9C246FEF680FB1C97A&quot;,
      &quot;latest_block_height&quot;: &quot;86392&quot;,
      &quot;latest_block_time&quot;: &quot;2022-02-24T14:32:08.673989Z&quot;,
      &quot;earliest_block_hash&quot;: &quot;0A73CFE8566D4D4FBFE3178D9BCBAD483FD689854CA8012FF1457F8EC4598132&quot;,
      &quot;earliest_app_hash&quot;: &quot;E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855&quot;,
      &quot;earliest_block_height&quot;: &quot;1&quot;,
      &quot;earliest_block_time&quot;: &quot;2022-01-20T09:04:21.549736Z&quot;,
      &quot;catching_up&quot;: false
    },
    &quot;validator_info&quot;: {
      &quot;address&quot;: &quot;6FD56E6AA1EEDAD227AFAB6B9DE631719D4A3691&quot;,
      &quot;pub_key&quot;: {
        &quot;type&quot;: &quot;tendermint/PubKeyEd25519&quot;,
        &quot;value&quot;: &quot;mR5V/QWOv/mJYyNmlsl3mfxKy1PNaOzdztyas4NF2BA=&quot;
      },
      &quot;voting_power&quot;: &quot;10&quot;
    }
  }
}
2022-02-24T14:32:14.052503Z DEBUG ThreadId(21) Incoming response: {
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;id&quot;: &quot;0ca35e64-ea98-4fbf-bd66-c3291128ace9&quot;,
  &quot;result&quot;: {}
}

...
</code></pre>
<p>The two DEBUG log lines above were emitted by the <code>tendermint-rpc</code> crate.</p>
<h2 id="inspecting-the-relayer-state"><a class="header" href="#inspecting-the-relayer-state">Inspecting the relayer state</a></h2>
<p>To get a little bit of insight into the state of the relayer,
Hermes will react to a <code>SIGUSR1</code> signal by dumping its state to
the console, either in plain text form or as a JSON object if Hermes
was started with the <code>--json</code> option.</p>
<p>To send a <code>SIGUSR1</code> signal to Hermes, look up its process ID (below PID)
and use the following command:</p>
<pre><code class="language-shell">kill -SIGUSR1 PID
</code></pre>
<p>Hermes will print some information about the workers which are currently running.</p>
<p>For example, with three chains configured and one channel between each pair of chains:</p>
<pre><code class="language-text">INFO Dumping state (triggered by SIGUSR1)
INFO
INFO * Chains: ibc-0, ibc-1, ibc-2
INFO * Client workers:
INFO   - client::ibc-0-&gt;ibc-1:07-tendermint-0 (id: 5)
INFO   - client::ibc-0-&gt;ibc-2:07-tendermint-0 (id: 9)
INFO   - client::ibc-1-&gt;ibc-0:07-tendermint-0 (id: 1)
INFO   - client::ibc-1-&gt;ibc-2:07-tendermint-1 (id: 11)
INFO   - client::ibc-2-&gt;ibc-0:07-tendermint-1 (id: 3)
INFO   - client::ibc-2-&gt;ibc-1:07-tendermint-1 (id: 7)
INFO * Packet workers:
INFO   - packet::channel-0/transfer:ibc-0-&gt;ibc-1 (id: 2)
INFO   - packet::channel-0/transfer:ibc-1-&gt;ibc-0 (id: 6)
INFO   - packet::channel-0/transfer:ibc-2-&gt;ibc-0 (id: 10)
INFO   - packet::channel-1/transfer:ibc-0-&gt;ibc-2 (id: 4)
INFO   - packet::channel-1/transfer:ibc-1-&gt;ibc-2 (id: 8)
INFO   - packet::channel-1/transfer:ibc-2-&gt;ibc-1 (id: 12)
</code></pre>
<p>or in JSON form (prettified):</p>
<pre><code class="language-json">{
  &quot;timestamp&quot;: &quot;Jul 12 17:04:37.244&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;Dumping state (triggered by SIGUSR1)&quot;
  }
}
{
  &quot;chains&quot;: [
    &quot;ibc-0&quot;,
    &quot;ibc-1&quot;,
    &quot;ibc-2&quot;
  ],
  &quot;workers&quot;: {
    &quot;Client&quot;: [
      {
        &quot;id&quot;: 5,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-0&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-0&quot;
        }
      },
      {
        &quot;id&quot;: 9,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-0&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-0&quot;
        }
      },
      {
        &quot;id&quot;: 1,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-0&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-1&quot;
        }
      },
      {
        &quot;id&quot;: 11,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-1&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-1&quot;
        }
      },
      {
        &quot;id&quot;: 3,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-1&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-2&quot;
        }
      },
      {
        &quot;id&quot;: 7,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-1&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-2&quot;
        }
      }
    ],
    &quot;Packet&quot;: [
      {
        &quot;id&quot;: 2,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;src_channel_id&quot;: &quot;channel-0&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      },
      {
        &quot;id&quot;: 6,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;src_channel_id&quot;: &quot;channel-0&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      },
      {
        &quot;id&quot;: 10,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;src_channel_id&quot;: &quot;channel-0&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      },
      {
        &quot;id&quot;: 4,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;src_channel_id&quot;: &quot;channel-1&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      },
      {
        &quot;id&quot;: 8,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;src_channel_id&quot;: &quot;channel-1&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      },
      {
        &quot;id&quot;: 12,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;src_channel_id&quot;: &quot;channel-1&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      }
    ]
  }
}
</code></pre>
<h2 id="connecting-to-a-full-node-protected-by-http-basic-authentication"><a class="header" href="#connecting-to-a-full-node-protected-by-http-basic-authentication">Connecting to a full node protected by HTTP Basic Authentication</a></h2>
<p>To connect to a full node protected by <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication">HTTP Basic Authentication</a>,
specify the username and password in the <code>rpc_addr</code>, <code>grpc_addr</code> and <code>websocket_addr</code> settings
under the chain configuration in <code>config.toml</code>.</p>
<p>Here is an example with username <code>hello</code> and password <code>world</code>, assuming the RPC, WebSocket and gRPC servers
listen on domain <code>mydomain.com</code> with TLS enabled (HTTPS/WSS).</p>
<pre><code class="language-toml">[[chains]]
id = 'my-chain-0'

# ...

rpc_addr = 'https://hello:world@mydomain.com:26657'
grpc_addr = 'https://hello:world@mydomain.com:9090'
websocket_addr = 'wss://hello:world@mydomain.com:26657/websocket'

# ...
</code></pre>
<blockquote>
<p><strong>Caution:</strong> Warning: The &quot;Basic&quot; authentication scheme sends the credentials encoded but not encrypted.
This would be completely insecure unless the exchange was over a secure connection (HTTPS/TLS).</p>
</blockquote>
<h2 id="patching-gaia-to-support-chancloseinit"><a class="header" href="#patching-gaia-to-support-chancloseinit">Patching <code>gaia</code> to support <code>ChanCloseInit</code></a></h2>
<p>The guide below refers specifically to patching your gaia chain so that the
relayer can initiate the closing of channels by submitting a <a href="./commands/tx/channel-close.html#channel-close-init"><code>ChanCloseInit</code></a> message.
Without this modification, the transaction will be rejected.
We also describe how to test the channel closing feature.</p>
<ul>
<li>
<p>Clone the Cosmos SDK</p>
<pre><code class="language-shell">git clone https://github.com/cosmos/cosmos-sdk.git ~/go/src/github.com/cosmos/cosmos-sdk
cd ~/go/src/github.com/cosmos/cosmos-sdk
</code></pre>
</li>
<li>
<p>Apply these diffs:</p>
<pre><code>   --- a/x/ibc/applications/transfer/module.go
   +++ b/x/ibc/applications/transfer/module.go
   @@ -305,7 +305,7 @@ func (am AppModule) OnChanCloseInit(
           channelID string,
    ) error {
           // Disallow user-initiated channel closing for transfer channels
   -       return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, &quot;user cannot close channel&quot;)
   +       return nil
    }
</code></pre>
</li>
<li>
<p>Append the line below (watch for the placeholder <code>&lt;your&gt;</code>) as the last line
in your <code>go.mod</code> in the gaia clone:</p>
</li>
</ul>
<p><code>replace github.com/cosmos/cosmos-sdk =&gt; /Users/&lt;your&gt;/go/src/github.com/cosmos/cosmos-sdk</code></p>
<ul>
<li>Now <code>make build</code> and <code>make install</code> your local copy of gaia</li>
</ul>
<p>In order to test the correct operation during the channel close, perform the steps below.</p>
<ul>
<li>
<p>the channel should be in state open-open:</p>
</li>
<li>
<p>transfer of 5555 samoleans from <code>ibc-1</code> to <code>ibc-0</code>. This results in a
Tx to <code>ibc-1</code> for a <code>MsgTransfer</code> packet.
Make sure you're not relaying this packet (the relayer should not be running on
this path).</p>
<pre><code class="language-shell">hermes tx ft-transfer --receiver-chain ibc-0 --sender-chain ibc-1 --sender-port transfer --sender-channel channel-1 --amount 5555 --timeout-height-offset 1000 --number-msgs 1 --denom samoleans
</code></pre>
</li>
<li>
<p>now do the first step of channel closing: the channel will transition
to close-open:</p>
<pre><code class="language-shell">hermes --config config.toml tx chan-close-init --receiver-chain ibc-0 --sender-chain ibc-1 --receiver-connection connection-0 --receiver-port transfer --sender-port transfer --receiver-channel channel-0 --sender-channel channel-1
</code></pre>
</li>
<li>
<p>trigger timeout on close to ibc-1</p>
<pre><code class="language-shell">hermes --config config.toml tx packet-recv --receiver-chain ibc-0 --sender-chain ibc-1 --sender-port transfer --sender-channel channel-1
</code></pre>
</li>
<li>
<p>close-close</p>
<pre><code class="language-shell">hermes --config config.toml tx chan-close-confirm --receiver-chain ibc-1 --sender-chain ibc-0 --receiver-connection connection-1 --receiver-port transfer --sender-port transfer --receiver-channel channel-1 --sender-channel channel-0
</code></pre>
</li>
<li>
<p>verify that the two ends are in Close state:</p>
<pre><code class="language-shell">hermes --config config.toml query channel end --chain ibc-0 --port transfer --channel channel-0
hermes --config config.toml query channel end --chain ibc-1 --port transfer --channel channel-1
</code></pre>
</li>
</ul>
<h2 id="new-feature-request"><a class="header" href="#new-feature-request">New Feature Request</a></h2>
<p>If you would like a feature to be added to <code>hermes</code>, don't hesitate
to open a discussion about that via the <a href="https://github.com/informalsystems/ibc-rs/issues/new?assignees=&amp;labels=&amp;template=feature-request.md">feature request</a>
issue template.</p>
<blockquote>
<p>Note that Hermes is packaged as part of the <code>ibc-relayer-cli</code> crate.</p>
</blockquote>
<h2 id="profiling"><a class="header" href="#profiling">Profiling</a></h2>
<p>The <code>relayer</code> crate provides a <code>time!</code> macro which can be used to measure how much time is spent between the invocation of the macro and the end of the enclosing scope.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>The <code>time!</code> macro has no effect unless the <code>profiling</code> feature of the <code>relayer</code> crate is enabled.</p>
<p>To enable it, one must compile the <code>relayer-cli</code> crate with the <code>--features=profiling</code> flag.</p>
<p>a) One way is to build the <code>relayer</code> binary and update the <code>hermes</code> alias to point to the executable:</p>
<pre><code class="language-shell">cd relayer-cli/
cargo build --features=profiling
</code></pre>
<p>b) Alternatively, one can use the <code>cargo run</code> command and update the alias accordingly:</p>
<pre><code class="language-shell">alias hermes='cargo run --features=profiling --manifest-path=relayer-cli/Cargo.toml --'
</code></pre>
<p>The <code>--manifest-path=relayer-cli/Cargo.toml</code> flag is needed for <code>cargo run</code> to accept the <code>--features</code> flag.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_function(x: u32) -&gt; u32 {
    time!(&quot;myfunction: x={}&quot;, x); // A

    std::thread::sleep(Duration::from_secs(1));

    {
        time!(&quot;inner operation&quot;); // B

        std::thread::sleep(Duration::from_secs(2));

        // timer B ends here
    }

    x + 1

    // timer A ends here
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="output"><a class="header" href="#output">Output</a></h4>
<pre><code>Jan 20 11:28:46.841  INFO relayer::macros::profiling: ⏳ myfunction: x=42 - start
Jan 20 11:28:47.842  INFO relayer::macros::profiling:    ⏳ inner operation - start
Jan 20 11:28:49.846  INFO relayer::macros::profiling:    ⏳ inner operation - elapsed: 2004ms
Jan 20 11:28:49.847  INFO relayer::macros::profiling: ⏳ myfunction: x=42 - elapsed: 3005ms
</code></pre>
<p>Profiling is useful for tracking down unusually slow methods.
Each transaction or query usually consists of multiple lower-level methods,
and it's often not clear which of these are the culprit for low performance.
With profiling enabled, <code>hermes</code> will output timing information for individual
methods involved in a command.</p>
<p><strong>NOTE</strong>: To be able to see the profiling output, the realyer needs to be compiled with
the <code>profiling</code> feature and the <a href="./help.html#parametrizing-the-log-output-level">log level</a> should be <code>info</code> level or lower.</p>
<h4 id="example-output-for-tx-conn-init-command"><a class="header" href="#example-output-for-tx-conn-init-command">Example output for <code>tx conn-init</code> command</a></h4>
<pre><code>hermes --config config.toml tx conn-init --b-chain ibc-0 --a-chain ibc-1 --b-client 07-tendermint-0 --a-client 07-tendermint-0
</code></pre>
<pre><code>Apr 13 20:58:21.225  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - start
Apr 13 20:58:21.230  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - elapsed: 4ms
Apr 13 20:58:21.230  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - start
Apr 13 20:58:21.235  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - elapsed: 5ms
Apr 13 20:58:21.235  INFO ibc_relayer::event::monitor: running listener chain.id=ibc-1
Apr 13 20:58:21.236  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - start
Apr 13 20:58:21.239  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - elapsed: 2ms
Apr 13 20:58:21.239  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - start
Apr 13 20:58:21.244  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - elapsed: 4ms
Apr 13 20:58:21.244  INFO ibc_relayer::event::monitor: running listener chain.id=ibc-0
Apr 13 20:58:21.244  INFO ibc_relayer::macros::profiling: ⏳ get_signer - start
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling: ⏳ get_signer - elapsed: 1ms
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling: ⏳ query_latest_height - start
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.248  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 1ms
Apr 13 20:58:21.249  INFO ibc_relayer::macros::profiling: ⏳ query_latest_height - elapsed: 3ms
Apr 13 20:58:21.250  INFO ibc_relayer::macros::profiling: ⏳ unbonding_period - start
Apr 13 20:58:21.250  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.251  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 0ms
Apr 13 20:58:21.270  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.273  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 2ms
Apr 13 20:58:21.273  INFO ibc_relayer::macros::profiling: ⏳ unbonding_period - elapsed: 23ms
Apr 13 20:58:21.279  INFO ibc_relayer::macros::profiling: ⏳ build_consensus_state - start
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling: ⏳ build_consensus_state - elapsed: 0ms
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling: ⏳ send_msgs - start
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling:    ⏳ send_tx - start
Apr 13 20:58:21.282  INFO ibc_relayer::macros::profiling:       ⏳ PK &quot;03f17d2c094ee68cfcedb2c2f2b7dec6cd82ea158ac1c32d3de0ca8b288a3c8bfa&quot; - start
Apr 13 20:58:21.282  INFO ibc_relayer::macros::profiling:          ⏳ block_on - start
Apr 13 20:58:21.285  INFO ibc_relayer::macros::profiling:          ⏳ block_on - elapsed: 3ms
Apr 13 20:58:21.296  INFO ibc_relayer::macros::profiling:             ⏳ block_on - start
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:             ⏳ block_on - elapsed: 1367ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:       ⏳ PK &quot;03f17d2c094ee68cfcedb2c2f2b7dec6cd82ea158ac1c32d3de0ca8b288a3c8bfa&quot; - elapsed: 1382ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:    ⏳ send_tx - elapsed: 1384ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling: ⏳ send_msgs - elapsed: 1384ms
Success: CreateClient(
    CreateClient(
        Attributes {
            height: Height {
                revision: 0,
                height: 10675,
            },
            client_id: ClientId(
                &quot;07-tendermint-7&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 1,
                height: 10663,
            },
        },
    ),
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>These are some of the definitions used in this guide:</p>
<div class="table-wrapper"><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody>
<tr><td>IBC transaction</td><td>A transaction that includes IBC messages (including packets). This is constructed by the relayer and sent over the physical network to a chain according to the chain rules. For example, for tendermint chains a <code>broadcast_tx_commit</code> request is sent to a tendermint RPC server.</td></tr>
<tr><td>IBC message</td><td>An element of the transaction payload sent by the relayer; it includes client, connection, channel and IBC packet data. Multiple IBC messages may be included in an IBC transaction.</td></tr>
<tr><td>IBC packet</td><td>A particular type of IBC message that includes the application packet and its commitment proof.</td></tr>
<tr><td>IBC Client</td><td>Client code running on chain, typically only the light client verification related functionality.</td></tr>
<tr><td>Relayer Light Client</td><td>Full light client functionality, including connecting to at least one provider (full node), storing and verifying headers, etc.</td></tr>
<tr><td>Source chain</td><td>The chain from which the relayer reads data to fill an IBC message.</td></tr>
<tr><td>Destination chain</td><td>The chain where the relayer submits transactions that include the IBC message.</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
